HELP.md:
<code>
# Getting Started

### Reference Documentation
For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.3/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.5.3/maven-plugin/build-image.html)
* [Spring Web](https://docs.spring.io/spring-boot/3.5.3/reference/web/servlet.html)
* [Spring Data JPA](https://docs.spring.io/spring-boot/3.5.3/reference/data/sql.html#data.sql.jpa-and-spring-data)

### Guides
The following guides illustrate how to use some features concretely:

* [Building a RESTful Web Service](https://spring.io/guides/gs/rest-service/)
* [Serving Web Content with Spring MVC](https://spring.io/guides/gs/serving-web-content/)
* [Building REST services with Spring](https://spring.io/guides/tutorials/rest/)
* [Accessing Data with JPA](https://spring.io/guides/gs/accessing-data-jpa/)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.


</code>

pom.xml:
<code>
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.5.3</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>com.brentcodes</groupId>
	<artifactId>librarysystem</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>springboot</name>
	<description>Demo Project for Spring Boot</description>
	<url/>
	<licenses>
		<license/>
	</licenses>
	<developers>
		<developer/>
	</developers>
	<scm>
		<connection/>
		<developerConnection/>
		<tag/>
		<url/>
	</scm>
	<properties>
		<java.version>21</java.version>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.postgresql</groupId>
			<artifactId>postgresql</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>

		<!-- Lombok -->
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>

		<!-- Spring Security -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>

		<!-- JWT -->
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-api</artifactId>
			<version>0.11.5</version>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-impl</artifactId>
			<version>0.11.5</version>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-jackson</artifactId>
			<version>0.11.5</version>
		</dependency>

		<!-- Spring Session -->
		<!-- Required for Spring Session JDBC to run -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jdbc</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.session</groupId>
			<artifactId>spring-session-jdbc</artifactId>
		</dependency>

		<!-- Spring Validation -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<annotationProcessorPaths>
						<path>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</path>
					</annotationProcessorPaths>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>

</code>

src\main\java\com\brentcodes\springboot\SpringbootApplication.java:
<code>
package com.brentcodes.springboot;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringbootApplication {
	public static void main(String[] args) {
		SpringApplication.run(SpringbootApplication.class, args);
	}


}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\DemoController.java:
<code>
package com.brentcodes.springboot.librarysystem;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/demo-controller")
public class DemoController {
    @GetMapping
    public ResponseEntity<String> sayHello() {
        return ResponseEntity.ok("Hello from secured endpoint");
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\admin\AdminController.java:
<code>
package com.brentcodes.springboot.librarysystem.admin;

import com.brentcodes.springboot.librarysystem.authentication.AuthenticationService;
import com.brentcodes.springboot.librarysystem.authentication.RegisterRequest;
import com.brentcodes.springboot.librarysystem.backendconfig.ApiResponse;
import com.brentcodes.springboot.librarysystem.project.Project;
import com.brentcodes.springboot.librarysystem.project.ProjectService;
import com.brentcodes.springboot.librarysystem.sessionconfig.SessionService;
import com.brentcodes.springboot.librarysystem.user.Role;
import com.brentcodes.springboot.librarysystem.user.User;
import com.brentcodes.springboot.librarysystem.user.UserRepository;
import com.brentcodes.springboot.librarysystem.uservulnerability.RoleInVuln;
import com.brentcodes.springboot.librarysystem.uservulnerability.UserVulnerability;
import com.brentcodes.springboot.librarysystem.vulnerability.Severity;
import com.brentcodes.springboot.librarysystem.vulnerability.Vulnerability;
import com.brentcodes.springboot.librarysystem.vulnerability.VulnerabilityService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.*;

import java.time.Instant;
import java.util.List;

@RestController
@RequestMapping(path = "api/v1/admin")
public class AdminController {
    private final AdminService adminService;
    private final AuthenticationService authenticationService;
    private final UserRepository userRepository;
    private final VulnerabilityService vulnerabilityService;
    private final SessionService sessionService;
    private final ProjectService projectService;

    public AdminController(AdminService adminService, AuthenticationService authenticationService,  UserRepository userRepository, VulnerabilityService vulnerabilityService, SessionService sessionService,  ProjectService projectService) {
        this.adminService = adminService;
        this.authenticationService = authenticationService;
        this.userRepository = userRepository;
        this.vulnerabilityService = vulnerabilityService;
        this.sessionService = sessionService;
        this.projectService = projectService;
    }
    // USER FUNCTIONS

    // üîê ADMIN: View all users; Returns List<User>
    @GetMapping(path = "/users") // manage users
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse> getUsers() {
        return ResponseEntity.ok(new ApiResponse(true, "Users retrieved successfully", adminService.getUsers()));
    }


    // üîê ADMIN: Find specific user by email; Returns User
    @GetMapping(path = "/users/email/{email}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse> getUserByEmail(@PathVariable("email") String email) {
        return ResponseEntity.ok(new ApiResponse(true, "User with email " + email + " retrieved successfully", adminService.getUserByEmail(email)));
    }

    // Takes payload for a user and stores it in database (does not log them or give access tokens like we saw in the other register method)
    // THIS IS CALLED DTO since we are formatting json into a class "user"
    @PostMapping(path = "/users/add")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse> addUser(@RequestBody RegisterRequest request,
                                               @RequestParam(defaultValue = "USER") Role role /* exclusive to admin registering a user */) {
        User adminCreatedUser = authenticationService.registerAsAdmin(request, role);
        return ResponseEntity.ok(new ApiResponse(true, "User added successfully", adminCreatedUser));
    }

    // Seamless because old access tokens can have expired first or last names (not needed for auth)
    @PutMapping(path = "/users/update/info/{userId}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse> updateUserFirstOrLastName(
            @PathVariable("userId") Long userId,
            @RequestParam(required = false) String firstName,
            @RequestParam(required = false) String lastName)
    {
        adminService.updateUserFirstOrLastName(userId, firstName, lastName);
        return ResponseEntity.ok(new ApiResponse(true, "First or Last name changed successfully"));
    }

    // Cannot be seamless because these are credentials required for authentication
    @PutMapping(path = "/users/update/credentials/{userId}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<ApiResponse> updateUserEmailOrPassword(
            @PathVariable("userId") Long userId,
            @RequestParam(required = false) String email,
            @RequestParam(required = false) String password)
    {
        User user = adminService.updateUserEmailOrPassword(userId, email, password);

        // ‚úÖ Revoke all sessions tied to this user
        sessionService.invalidateAllSessions(user.getId());

        // ‚úÖ Force token expiration by bumping credentialsChangedAt (redundant after delete, but useful if soft-deleting)
        user.setCredentialsChangedAt(Instant.now()); // Optional if you delete right after

        return ResponseEntity.ok(new ApiResponse(true, "Email or password changed successfully"));
    }

    // All deleting user logic is in the controller (http stuff kinda basically)
    @Transactional
    @DeleteMapping(path = "/users/delete/{userId}")
    @PreAuthorize("hasRole('ADMIN')")
    public void deleteUser(@PathVariable Long userId) {
        User user = userRepository.findById(userId) // we have this because we are just clicking a button that has id from the path (kinda)
                .orElseThrow(() -> new IllegalStateException("User not found"));

        // ‚úÖ 1. Revoke all sessions tied to this user
        sessionService.invalidateAllSessions(user.getId());

        // ‚úÖ 2. Force token expiration by bumping credentialsChangedAt (redundant after delete, but useful if soft-deleting)
        user.setCredentialsChangedAt(Instant.now()); // Optional if you delete right after

        // ‚úÖ 3. Delete the user
        userRepository.deleteById(userId);
    }

    // =======================================Vulnerability Functions===========================================
    // View all vulnerabilities (whether resolved or not); Returns List<Vulnerability> (check status for service)
    @GetMapping(path = "/all")
    public ResponseEntity<ApiResponse> getVulnerabilities() {
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities retrieved successfully", adminService.getVulnerabilities()));
    }

    // Get vulnerability by ID
    @GetMapping("/{vulnerabilityId}")
    public ResponseEntity<ApiResponse> getVulnerabilityById(@PathVariable Long vulnerabilityId) {
        Vulnerability vuln = adminService.getVulnerabilityById(vulnerabilityId);
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerability retrieved", vuln));
    }

    // Search by title
    @GetMapping("/title/{title}")
    public ResponseEntity<ApiResponse> getVulnerabilityByTitle(@PathVariable String title) {
        Vulnerability vuln = adminService.getVulnerabilityByTitle(title);
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerability found", vuln));
    }

    // Filter by severity
    @GetMapping("/severity/{severity}")
    public ResponseEntity<ApiResponse> getVulnerabilitiesBySeverity(@PathVariable Severity severity) {
        return ResponseEntity.ok(new ApiResponse(true, "Filtered by severity", adminService.getVulnerabilitiesBySeverity(severity)));
    }

    // Get overdue vulnerabilities
    @GetMapping("/overdue")
    public ResponseEntity<ApiResponse> getOverdueVulnerabilities() {
        return ResponseEntity.ok(new ApiResponse(true, "Overdue vulnerabilities", adminService.getOverdueVulnerabilities()));
    }

    // update/delete vulnerabilities maybe

    // ======================================== Project Functions ==================================================
// ‚úÖ Get All Projects
    @GetMapping
    public ResponseEntity<ApiResponse> getAllProjects() {
        List<Project> projects = adminService.getAllProjects();
        return ResponseEntity.ok(new ApiResponse(true, "Projects retrieved", projects));
    }

    // ‚úÖ Get Project by ID
    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse> getProjectById(@PathVariable Long id) {
        Project project = adminService.getProjectById(id);
        return ResponseEntity.ok(new ApiResponse(true, "Project retrieved", project));
    }

//    // ‚úÖ Get Project by name (list because we will have overlap)
//    @GetMapping("/{id}")
//    public ResponseEntity<ApiResponse> getProjectsByName(@PathVariable String name) {
//        List<Project> projects = adminService.getProjectsByName(name);
//        return ResponseEntity.ok(new ApiResponse(true, "Project retrieved", projects));
//    }

    // update/delete projects maybe
}
</code>

src\main\java\com\brentcodes\springboot\librarysystem\admin\AdminService.java:
<code>
package com.brentcodes.springboot.librarysystem.admin;

import com.brentcodes.springboot.librarysystem.project.Project;
import com.brentcodes.springboot.librarysystem.project.ProjectRepository;
import com.brentcodes.springboot.librarysystem.userproject.UserProjectRepository;
import com.brentcodes.springboot.librarysystem.uservulnerability.*;
import com.brentcodes.springboot.librarysystem.vulnerability.Severity;
import com.brentcodes.springboot.librarysystem.vulnerability.VulnStatus;
import com.brentcodes.springboot.librarysystem.vulnerability.Vulnerability;
import com.brentcodes.springboot.librarysystem.vulnerability.VulnerabilityRepository;
import com.brentcodes.springboot.librarysystem.user.User;
import com.brentcodes.springboot.librarysystem.user.UserRepository;
import jakarta.persistence.EntityNotFoundException;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.List;

@Service
public class AdminService {

    private final PasswordEncoder passwordEncoder;
    private final UserRepository userRepository;

    private final VulnerabilityRepository vulnerabilityRepository;
    private final ProjectRepository projectRepository;
    private final UserVulnerabilityRepository userVulnerabilityRepository;
    private final UserProjectRepository userProjectRepository;

    public AdminService(PasswordEncoder passwordEncoder, UserRepository userRepository,
                        VulnerabilityRepository vulnerabilityRepository,
                       UserVulnerabilityRepository userVulnerabilityRepository,
                        ProjectRepository projectRepository,
                        UserProjectRepository userProjectRepository) {
        this.passwordEncoder = passwordEncoder;
        this.userRepository = userRepository;
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.userVulnerabilityRepository = userVulnerabilityRepository;
        this.projectRepository = projectRepository;
        this.userProjectRepository = userProjectRepository;
    }

    // interacts with database using JPA commands
    public List<User> getUsers() {
        // returns a list
        return userRepository.findAll();
    }
    public User getUserByEmail(String email) {
        // returns a list
        return userRepository.findByEmail(email)
                .orElseThrow(() -> new IllegalStateException("User with email '" + email + "' not found"));
    }

    // Seamless info change
    @Transactional
    public void updateUserFirstOrLastName(Long userId, String firstName, String lastName) {
        User user = userRepository.findById(userId) // we have this because we are just clicking a button that has id from the path (kinda)
                .orElseThrow(() -> new IllegalStateException("User not found"));

        boolean updated = false;

        if (firstName != null && !firstName.isBlank()) {
            user.setFirstname(firstName);
            updated = true;
        }

        if (lastName != null && !lastName.isBlank()) {
            user.setLastname(lastName);
            updated = true;
        }

        if (!updated) {
            throw new IllegalArgumentException("At least one non-blank field (firstName or lastName) must be provided.");
        }

        userRepository.save(user);
    }

    // Authorized credentials change (not seamless)
    @Transactional
    public User updateUserEmailOrPassword(Long userId, String email, String password) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalStateException("User not found"));

        boolean updated = false;

        if (email != null && !email.isBlank()) {
            user.setEmail(email);
            updated = true;
        }

        if (password != null && !password.isBlank()) {
            user.setPassword(passwordEncoder.encode(password));
            updated = true;
        }

        if (!updated) {
            throw new IllegalArgumentException("At least one non-blank field (firstName or lastName) must be provided.");
        }

        // else we have updated something to do with authentication
        user.setCredentialsChangedAt(Instant.now());

        userRepository.save(user);
        return user;
    }

    // ===========================================Admin Vulnerability Stuff=============================================
        // Later implementation
    @Transactional(readOnly = true) // Optional tag for read only stuff (basically all the methods in this class)
    public List<Vulnerability> getVulnerabilities() {
        // Lists cannot be optional so lambda statements that make easy conversion are kinda useless
        List<Vulnerability> vulnerabilities = vulnerabilityRepository.findAll();

        // I need to use is empty for lists
        if (vulnerabilities.isEmpty()) {
            throw new EntityNotFoundException("No vulnerabilities found");
        }

        return vulnerabilities;
    }

    public Vulnerability getVulnerabilityById(Long vulnerabilityId) {
        return vulnerabilityRepository.findVulnerabilityById(vulnerabilityId)
                .orElseThrow(() -> new EntityNotFoundException("Vulnerability with id '" + vulnerabilityId + "' not found"));
    }

    public Vulnerability getVulnerabilityByTitle(String title) {
        // use lambda statements for single object entities (not lists)
        return vulnerabilityRepository.findVulnerabilityByTitle(title)
                .orElseThrow(() -> new EntityNotFoundException("Vulnerability with title '" + title + "' not found"));
    }

    public List<Vulnerability> getVulnerabilitiesBySeverity(Severity severity) {
        List<Vulnerability> vulnerabilities = vulnerabilityRepository.findVulnerabilitiesBySeverity(severity);

        if (vulnerabilities.isEmpty()) {
            throw new EntityNotFoundException("Vulnerabilities with severity of " + severity + " not found");
        }
        return vulnerabilities;
    }

    public List<Vulnerability> getOverdueVulnerabilities() {
        List<Vulnerability> vulnerabilities = vulnerabilityRepository.findByDueAtBeforeAndStatusNot(Instant.now(), VulnStatus.VERIFIED);

        if (vulnerabilities.isEmpty()) {
            throw new EntityNotFoundException("No overdue vulnerabilities found");
        }
        return vulnerabilities;
    }

    // =============================================== Project Functions ====================================
    // Get All Projects
    @Transactional(readOnly = true)
    public List<Project> getAllProjects() {
        return projectRepository.findAll();
    }

    // Get Project by ID
    @Transactional(readOnly = true)
    public Project getProjectById(Long id) {
        return projectRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Project not found with ID " + id));
    }

    // ‚úÖ Get Projects by name
    @Transactional(readOnly = true)
    public List<Project> getProjectsByName(String name) {
        List<Project> results = projectRepository.findByName(name);
        if (results.isEmpty()) {
            throw new EntityNotFoundException("No projects found with name: " + name);
        }
        return results;
    }






    // ===========================================Admin UserVuln Stuff=============================================
//    // Assign user to a vulnerability with a specific role
//    @Transactional
//    public User assignUserToVulnerability(VulnerabilityAssignAction action, RoleInVuln role) {
//        Long userId = action.userId();
//        Long vulnId = action.vulnId();
//        User user = userRepository.findById(action.userId())
//                .orElseThrow(() -> new UsernameNotFoundException("User not found with ID: " + userId));
//
//        Vulnerability vuln = vulnerabilityRepository.findById(action.vulnId())
//                .orElseThrow(() -> new EntityNotFoundException("Vulnerability not found with ID: " + vulnId));
//
//        UserVulnerabilityId id = new UserVulnerabilityId(userId, vulnId);
//
//        if (userVulnerabilityRepository.existsById(id)) {
//            throw new IllegalStateException("User already assigned to this vulnerability");
//        }
//
//        UserVulnerability assignment = UserVulnerability.builder()
//                .id(id)
//                .user(user)
//                .vulnerability(vuln)
//                .role(role)
//                .assignedAt(Instant.now())
//                .selfAssigned(false)
//                .build();
//
//        userVulnerabilityRepository.save(assignment);
//        return user;
//    }
//
//    // Revoke a user's assignment from a vulnerability
//    @Transactional
//    public User revokeUserFromVulnerability(VulnerabilityAssignAction action) {
//        Long userId = action.userId();
//        Long vulnId = action.vulnId();
//        User user = userRepository.findById(action.userId())
//                .orElseThrow(() -> new UsernameNotFoundException("User not found with ID: " + userId));
//
//        // checks user and vuln anyway so I don't need to do the user thing above, only needed it for returning.
//        UserVulnerabilityId id = new UserVulnerabilityId(userId, vulnId);
//
//        UserVulnerability existing = userVulnerabilityRepository.findById(id)
//                .orElseThrow(() -> new EntityNotFoundException("Assignment not found"));
//
//        userVulnerabilityRepository.delete(existing);
//        return user;
//    }
//
//
//    // Finds all reports by user
//    // Uses userVulnerabilityRepository JPA method
//    public List<UserVulnerability> getReportedByUser(Long userId) {
//        return userVulnerabilityRepository.findByUserId(userId);
//        // .stream()
//        // .map(UserVulnerability::getVulnerability)  // These are additional java methods that could be automated using @Query in the Repo
//        // .toList(); // We only needed them if we wanted to return a vulnerability, but now we are returning a uservulnerability!
//    }


}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\authentication\AuthenticationController.java:
<code>
package com.brentcodes.springboot.librarysystem.authentication;

import com.brentcodes.springboot.librarysystem.jwtconfig.JwtService;
import com.brentcodes.springboot.librarysystem.sessionconfig.SessionService;
import com.brentcodes.springboot.librarysystem.user.UserPrincipal;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpSession;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.time.Instant;
import java.util.Map;

@CrossOrigin(origins = "http://localhost:3000", allowCredentials = "true")
@RestController
@RequestMapping("/api/v1/auth")
@RequiredArgsConstructor
// Contains two endpoints that allow me to create/register a new account or authenticate an existing user
public class AuthenticationController {

    private final AuthenticationService authenticationService;
    private final JwtService jwtService;
    private final SessionService sessionService;

    // Adjust secure flag for localhost (false) vs HTTPS (true)
    // No longer used cuz its automatic with sessions
    // private static final boolean COOKIE_SECURE = false; set true in prod HTTPS (lombok ignores static fields)


    // Account creation
    // The service layer should not know anything about HTTP, sessions, headers, or web-specific APIs.
    @PostMapping("/register")
    public ResponseEntity<AuthenticationResponse> register(
            @RequestBody RegisterRequest request,              // üì© Incoming request body (email, password, etc.)
            HttpServletRequest httpReq                        // üåê Used to get metadata like User-Agent, IP
    ) {
        // Create userPrincipal object and return the authenticated userPrincipal
        UserPrincipal userPrincipal = authenticationService.register(request);

        // Create session
        HttpSession session = httpReq.getSession(true); // true = create session if one doesn't exist

        // Store user ID (or any info) as session attribute
        session.setAttribute("userId", userPrincipal.getId());

        // Generate short-lived access token using principal
        String jwt = jwtService.generateAccessToken(userPrincipal);

        // üì¶ Send access token (JWT) in response body ‚Äî this is for frontend to use in Authorization headers
        return ResponseEntity.ok(new AuthenticationResponse(jwt));
    }

    // same http and calls as register in the controller (service logic is different)... we will override old access tokens in the front end
    @PostMapping("/login")
    public ResponseEntity<AuthenticationResponse> login(
            @RequestBody AuthenticationRequest request,
            HttpServletRequest httpReq
    ) {
        // 1. Validate credentials and return authenticated UserPrincipal
        UserPrincipal userPrincipal = authenticationService.authenticate(request);

        // todo maybe invalidate existing sessions before creating them
        // todo I dont want the back button to cause login work arounds/hacks
        // todo I could just make it impossible to back track into login and only get there through log out idk
        // todo I might just not and let them expire
        // 2Ô∏è. Create a new HttpSession (or reuse existing one) and implicitly store in cookie (no Response only Req)
        HttpSession newSession = httpReq.getSession(true); // ‚úÖ Start fresh session for this login
        newSession.setAttribute("userId", userPrincipal.getId());


        // 3. Store user ID (or any info) as session attribute
        //     Spring Session JDBC will persist this to the DB:
        //     - SPRING_SESSION: stores session ID, creation time, expiry, etc.
        //     - SPRING_SESSION_ATTRIBUTES: stores key-value pairs like ("userId", 123L)
        // newSession.setAttribute("userId", userPrincipal.getId());    // You could also store the principal here

        // 4. Generate short-lived access token using principal
        String jwt = jwtService.generateAccessToken(userPrincipal);

        // 5. Return access token in response body
        return ResponseEntity.ok(new AuthenticationResponse(jwt));
    }


    // Refresh access token if session (which has a lifetime of about 7 days to match refresh token functionality) is still valid
    // Access token would be dead by this point so no need to check if it is valid or not
    @PostMapping("/refresh")
    public ResponseEntity<AuthenticationResponse> refresh(HttpServletRequest httpReq) {
        HttpSession session = httpReq.getSession(false); // doesnt create new session

        // üö´ If no session, unauthorized (no refresh token, no access)
        if (session == null || session.getAttribute("userId") == null) {
            return ResponseEntity.status(401).build(); // catch this in front end and redirect to login page
        }

        Long userId = (Long) session.getAttribute("userId");
        UserPrincipal principal = authenticationService.getPrincipalById(userId);
        String newJwt = jwtService.generateAccessToken(principal);

        return ResponseEntity.ok(new AuthenticationResponse(newJwt));
    }

    // Logout: invalidate session
    @PostMapping("/logout")
    public ResponseEntity<Void> logout(HttpServletRequest httpReq) {
        // Attempts to retrieve the current HTTP session, without creating a new one (false means "don't create if absent").
        // If there‚Äôs no session (user is already logged out), it returns null.
        sessionService.invalidateCurrentSession(httpReq);

        return ResponseEntity.noContent().build(); // Return 204: Kill Session, to be handled by front-end and re-directed to login page
    }

    // Logout: invalidate all existing sessions on all browsers (you need valid access token)
    // Follow Best Practice: You need to be logged in (with a valid access token) to log yourself out everywhere.
    @PostMapping("/logoutAllSessions")
    public ResponseEntity<Void> logoutAllSessions(Authentication authentication) {
        Long userId = ((UserPrincipal) authentication.getPrincipal()).getId();
        sessionService.invalidateAllSessions(userId);

        return ResponseEntity.noContent().build();
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\authentication\AuthenticationRequest.java:
<code>
package com.brentcodes.springboot.librarysystem.authentication;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
// Data-Transfer-Object (DTO).
public class AuthenticationRequest {
    private String email;
    private String password; // accessible in any class within the same package
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\authentication\AuthenticationResponse.java:
<code>
package com.brentcodes.springboot.librarysystem.authentication;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AuthenticationResponse {
    private String accessToken;
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\authentication\AuthenticationService.java:
<code>
package com.brentcodes.springboot.librarysystem.authentication;

import com.brentcodes.springboot.librarysystem.user.UserPrincipal;
import com.brentcodes.springboot.librarysystem.user.Role;
import com.brentcodes.springboot.librarysystem.user.User;
import com.brentcodes.springboot.librarysystem.user.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Slf4j // lombok logger
@Service
@RequiredArgsConstructor
// Implementation of register and authentication methods in controller
public class AuthenticationService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final AuthenticationManager authenticationManager;

    // Registers a new user in db and returns authenticated version for jwt creation in controller
    @Transactional
    public UserPrincipal register(RegisterRequest request) {
        String email = request.getEmail().trim().toLowerCase();

        // Application-level pre-check
        if (userRepository.existsByEmail(email)) {
            throw new IllegalArgumentException("Email is already in use");
        }

        User user = User.builder() // lombok import
                .firstname(request.getFirstname())
                .lastname(request.getLastname())
                .email(request.getEmail())
                .password(passwordEncoder.encode(request.getPassword())) // basically a sophisticated hash for passwords
                .role(Role.USER) // todo change this for registering admins, maybe you need to add a parameter idk?
                .build();
        userRepository.save(user); // saves the user into the database

        // Step 3: Build and return UserPrincipal
        return UserPrincipal.create(user);
    }

    // Verifies credentials and returns userPrincipal (for Spring Security)
    public UserPrincipal authenticate(AuthenticationRequest request) {
        // Step 1: Authenticate credentials
        authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                        request.getEmail(),
                        request.getPassword()
                )
        );

        // Step 2: Look up user by email (not ID)
        User user = userRepository.findByEmail(request.getEmail())
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Step 3: Build and return UserPrincipal
        return UserPrincipal.create(user);
    }

    // Get UserPrincipal from user object's id (good for the refresh implementation in controller)
    @Transactional
    public UserPrincipal getPrincipalById(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        return UserPrincipal.create(user);
    }

    // ============================================ ADMIN METHODS =====================================================
    @Transactional
    public User registerAsAdmin(RegisterRequest request, Role role) {
        String email = request.getEmail().trim().toLowerCase();

        if (userRepository.existsByEmail(email)) {
            throw new IllegalArgumentException("Email is already in use");
        }

        User user = User.builder()
                .firstname(request.getFirstname())
                .lastname(request.getLastname())
                .email(email)
                .password(passwordEncoder.encode(request.getPassword()))
                .role(role)
                .build();

        userRepository.save(user); // return User (not UserPrincipal)
        return user;
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\authentication\RegisterRequest.java:
<code>
package com.brentcodes.springboot.librarysystem.authentication;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
// Converts JSON to a Data-Transfer-Object for analyzation
public class RegisterRequest {
    private String firstname;
    private String lastname;
    private String email;
    private String password;
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\backendconfig\ApiResponse.java:
<code>
package com.brentcodes.springboot.librarysystem.backendconfig;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class ApiResponse {
    private Boolean success;
    private String message;
    private Object data; // Optional - can be null for errors

    // Constructor without data
    public ApiResponse(Boolean success, String message) {
        this.success = success;
        this.message = message;
        this.data = null;
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\backendconfig\DataInitializer.java:
<code>
package com.brentcodes.springboot.librarysystem.backendconfig;

import com.brentcodes.springboot.librarysystem.jwtconfig.JwtService;
import com.brentcodes.springboot.librarysystem.project.Project;
import com.brentcodes.springboot.librarysystem.project.ProjectRepository;
import com.brentcodes.springboot.librarysystem.userproject.ProjectRole;
import com.brentcodes.springboot.librarysystem.userproject.UserProject;
import com.brentcodes.springboot.librarysystem.userproject.UserProjectRepository;
import com.brentcodes.springboot.librarysystem.uservulnerability.RoleInVuln;
import com.brentcodes.springboot.librarysystem.uservulnerability.UserVulnerability;
import com.brentcodes.springboot.librarysystem.vulnerability.Severity;
import com.brentcodes.springboot.librarysystem.vulnerability.VulnStatus;
import com.brentcodes.springboot.librarysystem.vulnerability.Vulnerability;
import com.brentcodes.springboot.librarysystem.vulnerability.VulnerabilityRepository;
import com.brentcodes.springboot.librarysystem.uservulnerability.UserVulnerabilityRepository;
import com.brentcodes.springboot.librarysystem.user.Role;
import com.brentcodes.springboot.librarysystem.user.User;
import com.brentcodes.springboot.librarysystem.user.UserRepository;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.time.Instant;
import java.util.HashSet;
import java.util.List;

// Allow us to configure and create test data for Student, Vulnerability, and UserVulnerability (check relationships) classes
// Merged existing BookConfig and StudentConfig classes to prevent ordering problems
@Configuration
public class DataInitializer {
    @Bean // We are not using lombok, so I need to inject the beans into the constructors (@RequiredArgsConstructor)
    CommandLineRunner init(UserRepository userRepository, VulnerabilityRepository vulnerabilityRepository, ProjectRepository projectRepository, JwtService jwtService,
                           UserVulnerabilityRepository userVulnerabilityRepository, PasswordEncoder passwordEncoder,
                           UserProjectRepository userProjectRepository) {
        return args -> {
            // Create Projects and Users

            // === USER ===
            User diddy = new User();
            diddy.setEmail("diddy@gmail.com");
            diddy.setPassword(passwordEncoder.encode("123")); // plain password for testing
            diddy.setFirstname("Diddy");
            diddy.setLastname("Kong");
            diddy.setRole(Role.USER);
            userRepository.save(diddy);

            User brent = new User();
            brent.setEmail("bvilcas@gmail.com");
            brent.setPassword(passwordEncoder.encode("123")); // plain password for testing
            brent.setFirstname("Brent");
            brent.setLastname("Vilcas");
            brent.setRole(Role.USER);
            userRepository.save(brent);

            User epstein = new User();
            epstein.setEmail("epstein@gmail.com");
            epstein.setPassword(passwordEncoder.encode("123"));
            epstein.setFirstname("Jeffrey");
            epstein.setLastname("Epstein");
            epstein.setRole(Role.USER);
            userRepository.save(epstein);

            User trump = new User();
            trump.setEmail("trump@gmail.com");
            trump.setPassword(passwordEncoder.encode("123"));
            trump.setFirstname("Donald");
            trump.setLastname("Trump");
            trump.setRole(Role.ADMIN);
            userRepository.save(trump);

            // === PROJECTS ===
            Project project1 = new Project(
                    "Diddy Project",
                    "This is the starter project for testing.",
                    Instant.now(),
                    Instant.now()
            );
            projectRepository.save(project1);

            Project project2 = new Project(
                    "Epstein Project",
                    "This contains epstein emails and more.",
                    Instant.now(),
                    Instant.now()
            );
            projectRepository.save(project2);

            // === LINK USER ‚Üî PROJECT === (WE CAN DO THIS USING CREATE PROJECT METHOD BUT WE HAVE THAT CHECKED)
            UserProject link = new UserProject();
            link.setUser(diddy);
            link.setProject(project1);
            link.setRole(ProjectRole.LEAD); // <-- user is project lead
            userProjectRepository.save(link);

            UserProject link1 = new UserProject();
            link1.setUser(brent);
            link1.setProject(project1);
            link1.setRole(ProjectRole.PROGRAMMER);
            userProjectRepository.save(link1);

            UserProject link2 = new UserProject();
            link2.setUser(epstein);
            link2.setProject(project2);
            link2.setRole(ProjectRole.LEAD);
            userProjectRepository.save(link2);

            /// TRUMP IS AN AUTO LEAD TO EVERYTHING SINCE HE IS ADMIN BY DEFINITION

            // CREATE VULNERABILITIES
            Vulnerability v1 = new Vulnerability(
                    "Authentication bypass in MFA",
                    "Attackers can brute-force 2FA codes due to missing retry limits.",
                    "CVE-2025-4101",
                    "CWE-307",
                    Severity.HIGH,
                    VulnStatus.REPORTED,
                    Instant.now().minusSeconds(86400), // reported 1 day ago
                    Instant.parse("2025-12-20T23:59:59Z"),
                    Instant.parse("2025-11-25T17:00:00Z"), // due at
                    null, // patchedAt
                    null,    // verifiedAt
                    "github.com/brentcodes/auth-service",
                    "c88fa91bdd0e4f9e9afb77d502aaf922cbb994d2",
                    project1
            );

            Vulnerability v2 = new Vulnerability(
                    "SQL Injection in search query",
                    "Unsanitized input appended to SQL statement allows data exfiltration.",
                    "CVE-2025-5533",
                    "CWE-89",
                    Severity.CRITICAL,
                    VulnStatus.IN_PROGRESS,
                    Instant.now().minusSeconds(172800), // reported 2 days ago
                    Instant.parse("2025-12-10T23:59:59Z"),
                    null,
                    null,
                    null,
                    "github.com/brentcodes/search-service",
                    "91eeaf2230fc4cb3b21ef1299b7c11cb865fbb90",
                    project1
            );

            Vulnerability v3 = new Vulnerability(
                    "Broken access control in document preview",
                    "Users can view other teams' files by guessing preview IDs.",
                    null,
                    "CWE-639",
                    Severity.HIGH,
                    VulnStatus.REPORTED,
                    Instant.now(),
                    Instant.parse("2025-11-30T23:59:59Z"),
                    null,
                    null,
                    null,
                    "github.com/brentcodes/document-service",
                    "2ab44aa9de991122e34f3d12bb123e88ad6711ac",
                    project2
            );

            ///  NO USER LINKED TO THIS VULNERABILITY
            Vulnerability v4 = new Vulnerability(
                    "Bwefewfwefwe",
                    "Users fwefwefiles bywefwefwefweeview IDs.",
                    null,
                    "CWE-639",
                    Severity.HIGH,
                    VulnStatus.REPORTED,
                    Instant.now(),
                    Instant.parse("2025-11-30T23:59:59Z"),
                    null,
                    null,
                    null,
                    "github.com/brentcodes/document-service",
                    "2ab44aa9de991122e34f3d12bb123e88ad6711ac",
                    project1
            );

            vulnerabilityRepository.save(v1);
            vulnerabilityRepository.save(v2);
            vulnerabilityRepository.save(v3);
            vulnerabilityRepository.save(v4);

            // Create UserVulnerability Links
            UserVulnerability uv1 = new UserVulnerability(
                    diddy,
                    v1,
                    RoleInVuln.REPORTER,
                    Instant.now().minusSeconds(86400), // reported 1 day ago
                    false,  // reporters are never "self-assigned"
                    null    // not completed
            );

            UserVulnerability uv2 = new UserVulnerability(
                    brent,
                    v2,
                    RoleInVuln.ASSIGNEE,
                    Instant.now(),
                    true,   // assigned himself as assignee
                    null
            );

            UserVulnerability uv3 = new UserVulnerability(
                    epstein,
                    v3,
                    RoleInVuln.VERIFIER,
                    Instant.now(),
                    false,
                    null
            );

            userVulnerabilityRepository.save(uv1);
            userVulnerabilityRepository.save(uv2);
            userVulnerabilityRepository.save(uv3);


            System.out.println("‚úÖ‚úÖ‚úÖ Ready for Import ‚úÖ‚úÖ‚úÖ");
        };
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\backendconfig\GlobalExceptionHandler.java:
<code>
package com.brentcodes.springboot.librarysystem.backendconfig;

import jakarta.persistence.EntityNotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.authorization.AuthorizationDeniedException;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.Map;

// Catches exceptions thrown and converts them into consistent JSON responses (shortcut: no try/catch needed in controllers)
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ApiResponse> handleIllegalArgument(IllegalArgumentException e) {
        return ResponseEntity
                .badRequest()
                .body(new ApiResponse(false, e.getMessage()));
    }

    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<ApiResponse> handleIllegalState(IllegalStateException e) {
        return ResponseEntity
                .badRequest()
                .body(new ApiResponse(false, e.getMessage()));
    }

    @ExceptionHandler(UsernameNotFoundException.class)
    public ResponseEntity<ApiResponse> handleUserNotFound(UsernameNotFoundException e) {
        return ResponseEntity
                .status(HttpStatus.NOT_FOUND)
                .body(new ApiResponse(false, e.getMessage()));
    }

    @ExceptionHandler({ AccessDeniedException.class, AuthorizationDeniedException.class })
    public ResponseEntity<ApiResponse> handleAccessDenied(Exception e) {
        return ResponseEntity
                .status(HttpStatus.FORBIDDEN)
                .body(new ApiResponse(false, "Access Denied: " + e.getMessage()));
    }

    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ApiResponse> handleEntityNotFound(EntityNotFoundException e) {
        return ResponseEntity
                .status(HttpStatus.NOT_FOUND)
                .body(new ApiResponse(false, e.getMessage()));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse> handleGeneral(Exception e) {
        e.printStackTrace();
        return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(new ApiResponse(false, "An unexpected error occurred"));
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse> handleValidationErrors(MethodArgumentNotValidException ex) {

        // Build a map of field ‚Üí error message
        Map<String, String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .collect(java.util.stream.Collectors.toMap(
                        fieldError -> fieldError.getField(),
                        fieldError -> fieldError.getDefaultMessage(),
                        (msg1, msg2) -> msg1 // keep first message if duplicate
                ));

        return ResponseEntity
                .badRequest()
                .body(new ApiResponse(false, "Validation failed", errors));
    }

}
</code>

src\main\java\com\brentcodes\springboot\librarysystem\jwtconfig\ApplicationConfig.java:
<code>
package com.brentcodes.springboot.librarysystem.jwtconfig;

import com.brentcodes.springboot.librarysystem.user.UserPrincipal;
import com.brentcodes.springboot.librarysystem.user.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@RequiredArgsConstructor // For dependency injection
public class ApplicationConfig {

    private final UserRepository userRepository;

    // Beans are typically defined in classes like configuration
    // A @Bean is a method that manually creates and returns an object, typically a one-liner
    // Hey Spring, whenever you need a UserDetailsService, use this custom implementation I just wrote as a lambda.
    @Bean
    public UserDetailsService userDetailsService() {
        return username -> userRepository.findByEmail(username)
                .map(UserPrincipal::create)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
    }

    // Data access object responsible for fetching user details and encoding passwords
    // There are many implementations
    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService());
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    // Manage authentication based on username and password
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\jwtconfig\JwtAuthenticationFilter.java:
<code>
package com.brentcodes.springboot.librarysystem.jwtconfig;

import com.brentcodes.springboot.librarysystem.user.User;
import com.brentcodes.springboot.librarysystem.user.UserRepository;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.time.Instant;

@Component
@RequiredArgsConstructor // lombak; creates constructor using any final field declared below (does dependency injection for us)
// Validate JWT and AuthenticationFilter
// This filter runs once per request and checks if a JWT token is present and valid. If it is, it sets up authentication in the SecurityContext.
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtService jwtService;
    // we want our own implementation
    private final UserDetailsService userDetailsService;

    private final UserRepository  userRepository;
    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {
        final String authHeader = request.getHeader("Authorization"); // header that contains JWT/bearer token
        final String jwt;
        final String userEmail;
        // check if it is a jwt token
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response); // passes filter without a seal of authorization (will be destroyed in SecurityConfig)
            return;
        }
        // extracts the token and saves it into a string constant
        jwt = authHeader.substring(7);

        // Ignore refresh tokens here; only access tokens should authenticate requests
        if (!jwtService.isAccessToken(jwt)) {
            filterChain.doFilter(request, response);
            return;
        }

        try {
            userEmail = jwtService.extractUsername(jwt);

            if (userEmail != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                User user = userRepository.findByEmail(userEmail)
                        .orElseThrow(() -> new UsernameNotFoundException("User not found"));

                Instant issuedAt = jwtService.extractIssuedAt(jwt).toInstant();
                Instant credsChangedAt = user.getCredentialsChangedAt();

                if (credsChangedAt != null && issuedAt.isBefore(credsChangedAt)) {
                    response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                    return;
                }

                UserDetails userDetails = this.userDetailsService.loadUserByUsername(userEmail);

                if (jwtService.isTokenValid(jwt, userDetails)) {
                    UsernamePasswordAuthenticationToken authToken =
                            new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                    authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    SecurityContextHolder.getContext().setAuthentication(authToken);
                }
            }
        } catch (Exception e) {
            // üî¥ Any bad JWT ‚Üí reject gracefully
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }

        filterChain.doFilter(request, response);
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\jwtconfig\JwtService.java:
<code>
package com.brentcodes.springboot.librarysystem.jwtconfig;

import com.brentcodes.springboot.librarysystem.user.UserPrincipal;
import io.jsonwebtoken.*;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import java.security.Key;
import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.function.Function;

// JWT Service. Also contains logic to build a JWT token so its basically JWT Token + Service
@Service
public class JwtService {
    private static final String SECRET_KEY =
            "ZmZmYTJiM2ZjNjYxNGMyZTYwNDg1ZmE1YjZjNTc3MGE3Njg4MTY2YzFhZWNmYWRmYjBlY2FkMmFiYjA2NzQ0ZA==";
    private static final long ACCESS_MINUTES = 60; // Typically 15, but 60 for testing

    public String generateAccessToken(UserPrincipal p) {
        Map<String,Object> claims = new HashMap<>();
        claims.put("typ", "access");
        // sets roles of the userPrincipal into the jwt
        claims.put("roles", p.getAuthorities().stream().map(GrantedAuthority::getAuthority).toList());
        return build(claims, p.getUsername(), Duration.ofMinutes(ACCESS_MINUTES), null);
    }


    // All the things within a JWT token
    public String extractUsername(String token) { return extractClaim(token, Claims::getSubject); }
    public String extractType(String token)     { return extractClaim(token, c -> (String)c.get("typ")); }
    public String extractJti(String jti)      { return extractClaim(jti, Claims::getId); } // we dont use
    public Date extractExpiration(String t)   { return extractClaim(t, Claims::getExpiration); }
    public Date extractIssuedAt(String t) { return extractClaim(t, Claims::getIssuedAt); }

    public boolean isTokenValid(String token, UserDetails user) {
        return extractUsername(token).equals(user.getUsername()) && !isExpired(token);
    }

    public boolean isAccessToken(String token)  { return "access".equals(extractType(token)); }

    private boolean isExpired(String token) { return extractExpiration(token).before(new Date()); }

    private <T> T extractClaim(String token, Function<Claims,T> resolver) {
        final Claims claims = Jwts.parserBuilder().setSigningKey(getSignInKey()).build()
                .parseClaimsJws(token).getBody();
        return resolver.apply(claims);
    }

    // custom build method for lombok
    private String build(Map<String,Object> claims, String subject, Duration ttl, String jti) {
        Instant now = Instant.now();
        return Jwts.builder() // specific Jwts builder that is not lombok
                .setClaims(claims)
                .setSubject(subject)
                .setIssuedAt(Date.from(now))
                .setExpiration(Date.from(now.plus(ttl)))
                .setId(jti) // null => omitted
                .signWith(getSignInKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    private Key getSignInKey() {
        byte[] keyBytes = Decoders.BASE64.decode(SECRET_KEY);
        return Keys.hmacShaKeyFor(keyBytes);
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\jwtconfig\SecurityConfiguration.java:
<code>
package com.brentcodes.springboot.librarysystem.jwtconfig;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import static org.springframework.security.config.Customizer.withDefaults;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
@RequiredArgsConstructor
public class SecurityConfiguration {

    private final JwtAuthenticationFilter jwtAuthFilter;
    private final AuthenticationProvider authenticationProvider;



    /**
     * Chain #1 ‚Üí /api/v1/auth/** endpoints (login, register, refresh, logout).
     * These are allowed publicly and may use sessions (IF_REQUIRED).
     */
    @Bean
    @Order(1)
    public SecurityFilterChain authChain(HttpSecurity http) throws Exception {
        return http
                .securityMatcher("/api/v1/auth/**") // only matches auth endpoints
                .cors(withDefaults())
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(auth -> auth
                        .anyRequest().permitAll()
                )
                .sessionManagement(sess ->
                        sess.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
                )
                .authenticationProvider(authenticationProvider)
                .build();
    }

    /**
     * Chain #2 ‚Üí /api/** endpoints (everything else).
     * These must be stateless and secured by JWT only.
     */
    @Bean
    @Order(2)
    public SecurityFilterChain apiChain(HttpSecurity http) throws Exception {
        return http
                .securityMatcher("/api/**") // everything else under /api
                .cors(withDefaults())
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(auth -> auth
                        .anyRequest().authenticated()
                )
                .sessionManagement(sess ->
                        sess.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                )
                .authenticationProvider(authenticationProvider)
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
                .build();
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\project\Project.java:
<code>
package com.brentcodes.springboot.librarysystem.project;

import com.brentcodes.springboot.librarysystem.userproject.UserProject;
import com.brentcodes.springboot.librarysystem.vulnerability.Vulnerability;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "project")
@JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})
public class Project {
    @Id
    // Auto-Generation
    @SequenceGenerator(
            name = "project_sequence",         // Name used inside the Java app to refer to this generator
            sequenceName = "project_sequence", // Name of the actual database sequence object
            allocationSize = 1                 // Number of IDs to allocate at once (1 = no batching; get a new ID every time)
    )
    @GeneratedValue(
            strategy = GenerationType.SEQUENCE,  // Use a database sequence to generate the ID
            generator = "project_sequence"       // Link this ID generator to the one defined above
    )
    private Long id;
    private String name;
    private String description;
    private Instant createdAt;
    private Instant updatedAt;

    // Project ‚Üî User
    @OneToMany(mappedBy = "project", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonIgnore // dont spam this when returning project in JSON format
    private Set<UserProject> userProjects = new HashSet<>();

    // Bidirectional relationship, no joining table
    // Project ‚Üî Vulnerability... we are sending info over to vuln (foreign key lives in vulnerability class)
    @OneToMany(mappedBy = "project", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonIgnore
    private Set<Vulnerability> vulnerabilities = new HashSet<>();

    // ‚úÖ Used for backend seeding (e.g., in DataInitializer), avoids @Id injection
    // ‚ö†Ô∏è Excludes auto-generated `id`
    // ‚ÑπÔ∏è Holds similar value to Lombok builder but excludes id
    public Project(String name, String description, Instant createdAt, Instant updatedAt) {
        this.name = name; // The rest are in updateVulnerabilityInfo
        this.description = description;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Project)) return false;
        Project other = (Project) o;
        return id != null && id.equals(other.id);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(id);
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\project\ProjectController.java:
<code>
package com.brentcodes.springboot.librarysystem.project;

import com.brentcodes.springboot.librarysystem.backendconfig.ApiResponse;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;


@RestController
@RequestMapping(path = "api/v1/projects")

public class ProjectController {
    private final ProjectService projectService;

    public ProjectController(ProjectService projectService) {
        this.projectService =  projectService;
    }

    // ‚úÖ Create Project
    @PostMapping("/create")
    public ResponseEntity<ApiResponse> createProject(@Valid @RequestBody ProjectCreationRequest request, Authentication authentication) {
        Project saved = projectService.createProject(request, authentication);
        return ResponseEntity.ok(new ApiResponse(true, "Project created", saved));
    }

    @PreAuthorize("@projectSecurity.hasProjectRole(authentication, #id, 'LEAD')")
    // ‚úÖ Update Project
    @PutMapping("/update/{id}")
    public ResponseEntity<ApiResponse> updateProject(
            @PathVariable Long id,
            @RequestBody ProjectUpdateRequest request,
            Authentication authentication
    ) {
        Project updated = projectService.updateProject(id, request, authentication);
        return ResponseEntity.ok(new ApiResponse(true, "Project updated", updated));
    }

    @PreAuthorize("@projectSecurity.hasProjectRole(authentication, #id, 'LEAD')")
    // ‚úÖ Delete Project (from mine so frontend would restrict this)
    @DeleteMapping("/delete/{id}")
    public ResponseEntity<ApiResponse> deleteProject(@PathVariable Long id, Authentication authentication) {
        System.out.println("Deleting project with id " + id);
        projectService.deleteProject(id, authentication);
        return ResponseEntity.ok(new ApiResponse(true, "Project deleted"));
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\project\ProjectCreationRequest.java:
<code>
package com.brentcodes.springboot.librarysystem.project;

import jakarta.validation.constraints.NotBlank;

public record ProjectCreationRequest(
    @NotBlank String name,
    String description
){}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\project\ProjectRepository.java:
<code>
package com.brentcodes.springboot.librarysystem.project;

import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface ProjectRepository extends JpaRepository<Project, Long> {
    List<Project> findByName(String name);
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\project\ProjectService.java:
<code>
package com.brentcodes.springboot.librarysystem.project;

import com.brentcodes.springboot.librarysystem.user.User;
import com.brentcodes.springboot.librarysystem.user.UserPrincipal;
import com.brentcodes.springboot.librarysystem.user.UserRepository;
import com.brentcodes.springboot.librarysystem.userproject.ProjectRole;
import com.brentcodes.springboot.librarysystem.userproject.UserProject;
import com.brentcodes.springboot.librarysystem.userproject.UserProjectRepository;
import jakarta.persistence.EntityNotFoundException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.RequestBody;

import java.time.Instant;
import java.util.List;

@Service
@Transactional
public class ProjectService {

    private final ProjectRepository projectRepository;
    private final UserRepository userRepository;
    private final UserProjectRepository userProjectRepository;

    public ProjectService(ProjectRepository projectRepository, UserRepository userRepository,  UserProjectRepository userProjectRepository) {
        this.projectRepository = projectRepository;
        this.userRepository = userRepository;
        this.userProjectRepository = userProjectRepository;
    }

    // ‚úÖ Create Project
    public Project createProject(ProjectCreationRequest request, Authentication authentication) {
        // 1. Get the authenticated user's ID (Runs JWT authentication filter)
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        // 2. Check user exists
        User user = userRepository.findById(userId).orElseThrow(() -> new UsernameNotFoundException("User not found with ID: " + userId));

        Project project = new Project(request.name(), request.description(), Instant.now(), null);
        UserProject userProject = new UserProject(user, project, ProjectRole.LEAD); // Make the creator a lead automatically
        projectRepository.save(project);
        userProjectRepository.save(userProject);
        return project;
    }

    // ‚úÖ Update Project
    public Project updateProject(Long id, ProjectUpdateRequest request, Authentication authentication) {
        // 1. Get the authenticated user's ID (Runs JWT authentication filter)
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        // 2. Check user exists
        userRepository.findById(userId).orElseThrow(() -> new UsernameNotFoundException("User not found with ID: " + userId));

        Project project = projectRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Project not found with ID " + id));

        // ‚úÖ Only update if the field was provided
        if (request.name() != null && !request.name().isBlank()) {
            project.setName(request.name());
        }

        if (request.description() != null && !request.description().isBlank()) {
            project.setDescription(request.description());
        }

        project.setUpdatedAt(Instant.now());

        return projectRepository.save(project);
    }

    // ‚úÖ Delete Project
    public void deleteProject(Long id, Authentication authentication) {
        // 1. Get the authenticated user's ID (Runs JWT authentication filter)
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        // 2. Check user exists
        userRepository.findById(userId).orElseThrow(() -> new UsernameNotFoundException("User not found with ID: " + userId));

        Project project = projectRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Project not found with ID " + id));


        System.out.println("User and projects checks are done");

        // ‚úÖ Vulnerabilities (and their UserVulnerability links) WILL cascade because collection is maintained
        projectRepository.delete(project);
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\project\ProjectUpdateRequest.java:
<code>
package com.brentcodes.springboot.librarysystem.project;

public record ProjectUpdateRequest(
        String name,
        String description
) {
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\sessionconfig\SessionConfig.java:
<code>
package com.brentcodes.springboot.librarysystem.sessionconfig;

import org.springframework.context.annotation.Configuration;
import org.springframework.session.jdbc.config.annotation.web.http.EnableJdbcHttpSession;

/*
    @EnableJdbcHttpSession(maxInactiveIntervalInSeconds = 1800) or do this in applicationproperties up to u
    - Sets default session timeout (in seconds)
    - 1800 = 30 minutes
    */

@Configuration
public class SessionConfig {
    // You can leave this empty unless customizing

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // üí° SessionConfig Customization Options
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // üç™ Cookie Customization (Optional)
    /*
    @Bean
    public CookieSerializer cookieSerializer() {
        DefaultCookieSerializer serializer = new DefaultCookieSerializer();
        serializer.setCookieName("SESSIONID");           // Rename cookie (default: JSESSIONID)
        serializer.setCookiePath("/");                   // Usually root
        serializer.setSameSite("Lax");                   // Can be "Strict", "Lax", or "None"
        serializer.setUseSecureCookie(true);             // Send only over HTTPS
        serializer.setUseHttpOnlyCookie(true);           // Prevent JavaScript access
        return serializer;
    }
    */

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // üõ†Ô∏è Optional: Customize Repository (Advanced)
    /*
    @Bean
    public JdbcIndexedSessionRepositoryCustomizer customizer() {
        return (repository) -> {
            repository.setDefaultMaxInactiveInterval(1800); // Custom default timeout per session
        };
    }
    */

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // üóÉÔ∏è Rename Session Tables (if needed)
    /*
    @EnableJdbcHttpSession(tableName = "MY_SESSIONS")
    - Overrides the default SPRING_SESSION table name
    - Make sure to update schema in DB too!
    */
}
</code>

src\main\java\com\brentcodes\springboot\librarysystem\sessionconfig\SessionService.java:
<code>
package com.brentcodes.springboot.librarysystem.sessionconfig;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpSession;
import lombok.RequiredArgsConstructor;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.util.Arrays;

@Service
@RequiredArgsConstructor
public class SessionService {

    private final JdbcTemplate jdbcTemplate;

    // Invalidate the current session
    public void invalidateCurrentSession(HttpServletRequest httpReq) {
        // Attempts to retrieve the current HTTP session, without creating a new one (false means "don't create if absent").
        // If there‚Äôs no session (user is already logged out), it returns null.
        if (httpReq.getCookies() != null) {
            Arrays.stream(httpReq.getCookies())
                    .forEach(c -> System.out.println("üç™ Cookie: " + c.getName() + " = " + c.getValue()));
        } else {
            System.out.println("üö´ No cookies received");
        }

        HttpSession session = httpReq.getSession(false);
        if (session != null) {
            System.out.println("‚úÖ Invalidating session: " + session.getId());
            session.invalidate();
        } else {
            System.out.println("‚ö†Ô∏è No session found for request");
        }
    }

    // Invalidate all sessions for a given user
    public void invalidateAllSessions(Long userId) {
        String sql = """
            DELETE FROM SPRING_SESSION
            WHERE PRIMARY_ID IN (
                SELECT SESSION_PRIMARY_ID 
                FROM SPRING_SESSION_ATTRIBUTES 
                WHERE ATTRIBUTE_NAME = 'userId'
                  AND CAST(ATTRIBUTE_BYTES AS VARCHAR) = ?
            )
            """;
        jdbcTemplate.update(sql, userId.toString());
    }
}


</code>

src\main\java\com\brentcodes\springboot\librarysystem\user\ChangePasswordRequest.java:
<code>
package com.brentcodes.springboot.librarysystem.user;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class ChangePasswordRequest {
    private String oldPassword;
    private String newPassword;
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\user\Role.java:
<code>
package com.brentcodes.springboot.librarysystem.user;

public enum Role {
    USER,
    ADMIN
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\user\UpdateProfileRequest.java:
<code>
package com.brentcodes.springboot.librarysystem.user;

import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
// Data container that is not responsible for logic
///  EXTRA LOGIC IN FRONTEND (no white space), IF BOTH ARE BLANK THEN DONT DO ANYTHING
public class UpdateProfileRequest {
    private String firstName;
    private String lastName;
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\user\User.java:
<code>
package com.brentcodes.springboot.librarysystem.user;

import com.brentcodes.springboot.librarysystem.uservulnerability.UserVulnerability;
import com.brentcodes.springboot.librarysystem.userproject.UserProject;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.lang.Nullable;

import java.time.Instant;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Data // lombak (generates everything needed)
// help me build my object in an easy way using a design pattern builder.
// more readable and flexible using .builder()
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})
// avoid ambiguity between this user class and the one on postgres (which contains my log in info)
@Table(name = "_user")
public class User {
    @Id
    // Auto-Generation
    @SequenceGenerator(
            name = "user_sequence",         // Name used inside the Java app to refer to this generator
            sequenceName = "user_sequence", // Name of the actual database sequence object
            allocationSize = 1                 // Number of IDs to allocate at once (1 = no batching; get a new ID every time)
    )
    @GeneratedValue(
            strategy = GenerationType.SEQUENCE,  // Use a database sequence to generate the ID
            generator = "user_sequence"       // Link this ID generator to the one defined above
    )
    private Long id;
    private String firstname;
    private String lastname;
    @Column(nullable = false, unique = true)
    private String email; // Everyone must have a unique email
    // already implemented because of lombak, I implemented anyway
    private String password;
    @Enumerated(EnumType.STRING) // Fixed set of constants. Will show as strings on the database and not # (ordinal)
    private Role role; // user can only have one role because the field "role" is just one enum value, not a list

    // "Hey, I‚Äôm User.java, and I know I‚Äôm related to many UserVulnerability entries via the vulnerability field in that class."
    @OneToMany(mappedBy = "user", orphanRemoval = true)
    private Set<UserVulnerability> userVulnerabilities = new HashSet<>();

    // User ‚Üî Project
    @OneToMany(mappedBy = "user", orphanRemoval = true)
    private Set<UserProject> userProjects = new HashSet<>();

    // Timestamp that is in UTC (perfect for comparing across systems and with JWTs whose iat, exp work with UTC)
    @Column(name = "password_changed_at")
    @Nullable // can be null
    private Instant credentialsChangedAt; // to prevent old access tokens from being used in other sessions

    // we need these cuz we are using email as "username"
    public String getUsername() {
        return email;
    }

    public void setUsername(String username) {
        this.email = username;
    }

    // ‚úÖ If you prefer explicit equals/hashCode instead of Lombok:
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof User)) return false;
        User other = (User) o;
        return id != null && Objects.equals(id, other.id);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(id);
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\user\UserController.java:
<code>
package com.brentcodes.springboot.librarysystem.user;

import com.brentcodes.springboot.librarysystem.authentication.AuthenticationResponse;
import com.brentcodes.springboot.librarysystem.backendconfig.ApiResponse;
import com.brentcodes.springboot.librarysystem.sessionconfig.SessionService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;


@RestController
@RequestMapping(path = "api/v1/users")

public class UserController {
    private final UserService userService;
    private final SessionService sessionService;

    public UserController(UserService userService, SessionService sessionService) {
        this.userService = userService;
        this.sessionService = sessionService;
    }

    @GetMapping("/me")
    public ResponseEntity<UserPrincipal> me(Authentication auth) {
        return ResponseEntity.ok((UserPrincipal) auth.getPrincipal());
    }

    @GetMapping("/profile")
    // @PreAuthorize("hasRole('STUDENT') or hasRole('ADMIN')"), I dont technically need this
    // We use authentication to get the user object bc it would be a security risk otherwise
    // Gets Profile of User, User
    public ResponseEntity<ApiResponse> getProfile(Authentication authentication) {
        return ResponseEntity.ok(new ApiResponse(true, "Profile retrieved successfully",  userService.getProfile(authentication)));
    }

    // Update firstname and lastname (does not update jwt because we are not changing authentication info); Returns confirmation
    @PutMapping("/update")
    public ResponseEntity<ApiResponse> updateUserInfo(@RequestBody UpdateProfileRequest request,
                                                     Authentication authentication) {
        userService.updateUserInfo(request, authentication);
        return ResponseEntity.ok(new ApiResponse(true, "First or last name updated successfully"));
    }

    // Changes email and forces logout across all sessions bc it is used in authentication (userPrincipal which builds JWT)
    @PutMapping("/update/{email}")
    public ResponseEntity<AuthenticationResponse> changeEmail(
            @PathVariable String email,
            Authentication authentication
    ) {
        // changes the email in the user object
        userService.changeEmail(email, authentication);

        // ‚úÖ Invalidate all sessions (including current session)
        Long userId = ((UserPrincipal) authentication.getPrincipal()).getId();
        sessionService.invalidateAllSessions(userId);

        // This is only applies to the current session
        // 204 = no content, frontend should redirect to log-in where the user can get a new access token
        return ResponseEntity.noContent().build();
    }

    // Changes password and forces logout across all sessions
    @PutMapping("/change-password")
    public ResponseEntity<ApiResponse> changePassword(
            @RequestBody ChangePasswordRequest request,
            Authentication authentication
    ) {
        userService.changePassword(request, authentication);

        // Invalidate all sessions (including current session)
        Long userId = ((UserPrincipal) authentication.getPrincipal()).getId();
        sessionService.invalidateAllSessions(userId);

        // This is only applies to the current session
        // 204 = no content, frontend should redirect to log-in where the user can get a new access token
        return ResponseEntity.noContent().build();
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\user\UserPrincipal.java:
<code>
package com.brentcodes.springboot.librarysystem.user;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.List;

// Implements all getters and setters
@Data
@Builder
@AllArgsConstructor // doesnt care about final or not

//  Java object that represents the currently authenticated user
public class UserPrincipal implements UserDetails {
    private Long id;
    private String username;
    private String password;
    private Role role;
    private Collection<? extends GrantedAuthority> authorities;

    // create a UserPrincipal Object from a user object (could be imported using lombok, but we have multiple uses)
    public static UserPrincipal create(User user) {
        List<GrantedAuthority> authorities = List.of(
                new SimpleGrantedAuthority("ROLE_" + user.getRole().name())
        );

        // we could use lombok here but the main advantage is when we are building from other classes (no need for 'manual' creation)
        return new UserPrincipal(
                user.getId(),
                user.getUsername(),
                user.getPassword(),
                user.getRole(),
                authorities
        );
    }

    // todo add checks for these while authenticating and registering
    @Override
    public boolean isAccountNonExpired() { return true; }

    @Override
    public boolean isAccountNonLocked() { return true; }

    @Override
    public boolean isCredentialsNonExpired() { return true; }

    @Override
    public boolean isEnabled() { return true; }

}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\user\UserRepository.java:
<code>
package com.brentcodes.springboot.librarysystem.user;

import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {

    Optional<User> findByEmail(String email);
    // or you can do @Query("SELECT s FROM Student s WHERE s.email = ?1")

    boolean existsByEmail(String email);
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\user\UserService.java:
<code>
package com.brentcodes.springboot.librarysystem.user;

import com.brentcodes.springboot.librarysystem.authentication.AuthenticationService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;

// Responsible for user account management
// Session killing should be instant (dealt with in the front; refresh tokens being revoked in the back end is all I can do for now)
@Service
public class UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    // true ‚Üí cookie is only sent over HTTPS (production). EXTRA PRECAUTIONS FOR APP PROPERTIES WHICH ALREADY DEFINES THIS
    // false ‚Üí cookie is sent over HTTP (local dev).
    // @Value("${app.auth.cookies.secure:true}")
    // private boolean cookieSecure;

    @Autowired
    public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }

    // We don't need cookie info, but need security info for identifying the user
    // Return User cuz it has all profile info, we return userPrincipal in AuthServices because we needed to create authenticated shit (tokens)
    @Transactional(readOnly = true) // skips entity scan
    public User getProfile(Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        return userRepository
                // lambda/java statement
                .findById(userPrincipal.getId())
                .orElseThrow(() -> new UsernameNotFoundException("Your account was not found"));
    }

    // We don't need cookie info, but need security info for identifying that wants to change their first/last name
    public void updateUserInfo(UpdateProfileRequest request, Authentication authentication) {
        // check input existence
        if (request.getFirstName() == null && request.getLastName() == null) {
            throw new IllegalArgumentException("At least one field must be provided to update.");
        }

        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        User user = userRepository.findById(userPrincipal.getId()).orElseThrow(()
                -> new UsernameNotFoundException("Your account was not found."));


        if (request.getFirstName() != null) {
            user.setFirstname(request.getFirstName()); // cant use builder cuz we are modifying field and not creating a new object
        }
        if (request.getLastName() != null) {
            user.setLastname(request.getLastName());
        }

        userRepository.save(user);
    }

    // Change email in user object for future and login identity (does not touch sessions... HTTP/controller responsibility)
    @Transactional
    public void changeEmail(String email, Authentication authentication) {
        if (email == null || email.isBlank()) {
            throw new IllegalArgumentException("New email must be provided.");
        }

        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        User user = userRepository.findById(userPrincipal.getId())
                .orElseThrow(() -> new UsernameNotFoundException("Your account was not found."));


        if (email.equalsIgnoreCase(user.getUsername())) {
            throw new IllegalArgumentException("New email is the same as current email.");
        }

        if (userRepository.existsByEmail(email)) {
            throw new IllegalArgumentException("Email is already in use.");
        }

        // ‚úÖ Update email/username
        user.setUsername(email);
        // Invalidate access tokens from other sessions (which do not have instant re-login logic)
        user.setCredentialsChangedAt(Instant.now());

        userRepository.save(user);
    }

    // Change password in user object for future and login identity (does not touch sessions... HTTP/controller responsibility)
    @Transactional
    public void changePassword(ChangePasswordRequest request, Authentication authentication) {
        if (request.getOldPassword() == null || request.getNewPassword() == null) {
            throw new IllegalArgumentException("Both old and new passwords are required.");
        }

        UserPrincipal principal = (UserPrincipal) authentication.getPrincipal();
        User user = userRepository.findById(principal.getId())
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        if (!passwordEncoder.matches(request.getOldPassword(), user.getPassword())) {
            throw new IllegalArgumentException("Current password is incorrect.");
        }

        if (passwordEncoder.matches(request.getNewPassword(), user.getPassword())) {
            throw new IllegalArgumentException("New password must be different.");
        }

        // ‚úÖ Update password
        user.setPassword(passwordEncoder.encode(request.getNewPassword()));
        // Invalidate access tokens from other sessions (which do not have instant re-login logic)
        user.setCredentialsChangedAt(Instant.now());

        userRepository.save(user);
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\userproject\AddMemberRequest.java:
<code>
package com.brentcodes.springboot.librarysystem.userproject;

import jakarta.validation.constraints.NotNull;

public record AddMemberRequest(
        @NotNull Long projectId,
        @NotNull Long userId,
        @NotNull ProjectRole role // e.g. "USER", "LEAD"
) {}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\userproject\ChangeProjectRoleCommand.java:
<code>
package com.brentcodes.springboot.librarysystem.userproject;

import jakarta.validation.constraints.NotNull;

public record ChangeProjectRoleCommand(
        @NotNull Long projectId,
        @NotNull Long userId,
        @NotNull ProjectRole newRole
) {}
</code>

src\main\java\com\brentcodes\springboot\librarysystem\userproject\ProjectMemberResponse.java:
<code>
package com.brentcodes.springboot.librarysystem.userproject;

public record ProjectMemberResponse(
        Long id,
        String firstname,
        String lastname,
        ProjectRole projectRole
) {}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\userproject\ProjectRole.java:
<code>
package com.brentcodes.springboot.librarysystem.userproject;

public enum ProjectRole {
    LEAD,   // full control: manage members, edit project, assign vulns
    PROGRAMMER,  // normal contributor: report vulns, self-assign
    TESTER   // verify patched stuff
}
</code>

src\main\java\com\brentcodes\springboot\librarysystem\userproject\ProjectSecurity.java:
<code>
package com.brentcodes.springboot.librarysystem.userproject;

import com.brentcodes.springboot.librarysystem.user.Role;
import com.brentcodes.springboot.librarysystem.user.User;
import com.brentcodes.springboot.librarysystem.user.UserPrincipal;
import com.brentcodes.springboot.librarysystem.user.UserRepository;
import jakarta.persistence.EntityNotFoundException;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

// Makes sure a user has access to a specific project and that they cant delete the whole thing
@Component("projectSecurity")
public class ProjectSecurity {
    private final UserProjectRepository userProjectRepository;

    public ProjectSecurity(UserProjectRepository userProjectRepository) {
        this.userProjectRepository = userProjectRepository;
    }

    // Only users with the required role (or admins) can perform the action
    public boolean hasProjectRole(Authentication auth, Long projectId, String requiredRole) {
        UserPrincipal principal = (UserPrincipal) auth.getPrincipal();
        Long userId = principal.getId();

        // ‚úÖ Always trust the authenticated principal‚Äôs role first
        if (principal.getRole() == Role.ADMIN)
            return true;

        // ‚úÖ Check user‚Äôs membership in the project
        return userProjectRepository.findByUserIdAndProjectId(userId, projectId)
                .map(up -> up.getRole().name().equalsIgnoreCase(requiredRole))
                .orElse(false);
    }

    // ‚úÖ Check if user is a project member at all
    /**
     * ‚úÖ Checks if the user is simply a member of the project (regardless of their specific role).
     * Admin always passes this check.
     */
    public boolean isProjectMember(Authentication auth, Long projectId) {
        UserPrincipal principal = (UserPrincipal) auth.getPrincipal();
        Long userId = principal.getId();

        if (principal.getRole() == Role.ADMIN)
            return true;

        return userProjectRepository.findByUserIdAndProjectId(userId, projectId).isPresent();
    }

    // ‚úÖ Get project-specific role for current user
    public ProjectRole getProjectRole(Authentication auth, Long projectId) {
        UserPrincipal principal = (UserPrincipal) auth.getPrincipal();
        Long userId = principal.getId();

        if (principal.getRole() == Role.ADMIN)
            return ProjectRole.LEAD;

        UserProject membership = userProjectRepository.findByUserIdAndProjectId(userId, projectId)
                .orElseThrow(() -> new AccessDeniedException("User is not a member of this project"));

        return membership.getRole();
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\userproject\ProjectSummaryDto.java:
<code>
package com.brentcodes.springboot.librarysystem.userproject;

import java.time.Instant;

public record ProjectSummaryDto(
        Long id,
        String name,
        String description,
        Instant createdAt,
        Instant updatedAt,
        String myRole
) {}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\userproject\RemoveMemberRequest.java:
<code>
package com.brentcodes.springboot.librarysystem.userproject;

import jakarta.validation.constraints.NotNull;

public record RemoveMemberRequest(
        @NotNull Long projectId,
        @NotNull Long userId
        ) {}
</code>

src\main\java\com\brentcodes\springboot\librarysystem\userproject\RoleCheckerResponse.java:
<code>
package com.brentcodes.springboot.librarysystem.userproject;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class RoleCheckerResponse {
    private Boolean warn;
    private String message;
    private String code; // Optional - can be null for errors

    // Constructor without data
    public RoleCheckerResponse(Boolean warn, String message) {
        this.warn = warn;
        this.message = message;
        this.code = null;
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\userproject\UserProject.java:
<code>
package com.brentcodes.springboot.librarysystem.userproject;

import com.brentcodes.springboot.librarysystem.project.Project;
import com.brentcodes.springboot.librarysystem.user.User;
import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;
import java.util.Objects;

@Entity
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserProject {
    @EmbeddedId
    private UserProjectId id = new UserProjectId();


    // MapsId takes the ID from the student and the ID from the vulnerability, and combine them to create the primary key for this record.
    // This primary key is also called the composite key in this context (merges the two primary/foreign keys)
    // Foreign keys live in the combining table
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("userId") // create foreign key
    @JoinColumn(name = "user_id")
    @JsonIgnore
    private User user;

    // @MapsId will generate an embedded ID, no need for sequence generation or instantiation in constructor
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("projectId") // boilerplate, references the UserVulnerabilityId composite create
    @JoinColumn(name = "project_id")
    @JsonIgnore
    private Project project;

    @Enumerated(EnumType.STRING)
    private ProjectRole role; // ADMIN, PROGRAMMER, VIEWER

    // Only for seeding (without id)
    public UserProject(User user, Project project, ProjectRole role) {
        this.user = user;
        this.project = project;
        this.role = role;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof UserProject)) return false;
        UserProject other = (UserProject) o;
        return id != null && id.equals(other.id);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(id);
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\userproject\UserProjectController.java:
<code>
package com.brentcodes.springboot.librarysystem.userproject;
import com.brentcodes.springboot.librarysystem.backendconfig.ApiResponse;
import com.brentcodes.springboot.librarysystem.project.Project;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping(path = "api/v1/userprojects")
public class UserProjectController {

    /// ADDING, REMOVING OTHER LEADS, AND CHANGING OTHER ROLES INTO LEADS ASK FOR CONFIRMATION
    /// CODES: PROMOTING_MEMBER_LEAD, ADDING_MEMBER_LEAD, REMOVING_MEMBER_LEAD

    /// DELETING YOURSELF (LAST LEAD) WILL GIVE WARNING AND FORCE YOU TO PROMOTE SOMEONE (CHANGEUSERROLE)
    /// CODES: "SELF_REMOVE_LAST_MEMBER" (CASCADE DELETE UPON VERIFICATION), "SELF_REMOVE_LAST_LEAD"
    private final UserProjectService userProjectService;

    public UserProjectController(UserProjectService userProjectService) {
        this.userProjectService = userProjectService;
    }

    ///  PROJECT MANAGEMENT

    @GetMapping("/all")
    public ResponseEntity<?> getMyProjects(Authentication authentication) {
        try {
            var data = userProjectService.getMyProjects(authentication);
            System.out.println("‚úÖ Retrieved projects: " + data.size());
            return ResponseEntity.ok(new ApiResponse(true, "Projects retrieved successfully", data));
        } catch (Exception e) {
            e.printStackTrace();  // <--- THIS prints the true 500 cause
            return ResponseEntity.internalServerError().body(e.getMessage());
        }
    }

    // I can also create a sort method that filters by created at in the front end (sort order)
    // This would return an ordered list that would be pasted in the front end
    // getMyProjectsSortedByCreatedAt

    // Get MY project by id
    @GetMapping("/{projectId}")
    public ResponseEntity<ApiResponse> getMyProjectById(@PathVariable Long projectId, Authentication authentication) {
        ProjectSummaryDto project = userProjectService.getMyProjectById(authentication, projectId);
        return ResponseEntity.ok(new ApiResponse(true, "Project retrieved", project));
    }

    // Search by name
    @GetMapping("/name/{name}")
    public ResponseEntity<ApiResponse> getMyProjectsByName(@PathVariable String name, Authentication authentication) {
        return ResponseEntity.ok(new ApiResponse(true, "Project found", userProjectService.getMyProjectByName(authentication, name)));
    }

    // THIS CAN PREVENT LEADS PROMOTING OTHER LEADS WITHOUT NOTIFICATION (CAUGHT IN FRONTEND)
    // Lead method only (to apply on users and themselves)
    @PreAuthorize("@projectSecurity.hasProjectRole(authentication, #request.projectId(), 'LEAD')")
    @PostMapping("/change")
    public ResponseEntity<ApiResponse> changeUserRoleInProject(@RequestBody ChangeProjectRoleCommand request) {
        RoleCheckerResponse response = userProjectService.changeUserRoleInProject(request);
        return ResponseEntity.ok(new ApiResponse(true, "User project role updated successfully", response));
    }

    ///  TEAM/USER MANAGEMENT
    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    @GetMapping("/members/{projectId}")
    public ResponseEntity<ApiResponse> getProjectMembers(@PathVariable Long projectId) {
        return ResponseEntity.ok(
                new ApiResponse(true, "Members retrieved", userProjectService.getProjectMembers(projectId))
        );
    }

    @PreAuthorize("@projectSecurity.hasProjectRole(authentication, #request.projectId(), 'LEAD')")
    @PostMapping("/members/add")
    public ResponseEntity<ApiResponse> addMemberToProject(@RequestBody AddMemberRequest request, Authentication authentication) {
        RoleCheckerResponse response = userProjectService.addMemberToProject(request);
        return ResponseEntity.ok(new ApiResponse(true, "Member added successfully", response));
    }

    // Verify that we can remove the member (called before RemoveMemberFromProject)
    @PreAuthorize("@projectSecurity.hasProjectRole(authentication, #request.projectId(), 'LEAD')")
    @PostMapping("/members/remove/validate")
    public ResponseEntity<ApiResponse> validateRemoveMember(@RequestBody RemoveMemberRequest request) {
        return ResponseEntity.ok(new ApiResponse(true, "Validation successful", userProjectService.validateRemoveMember(request)));
    }

    // If removing a lead, there must be confirmation before going through.
    @PreAuthorize("@projectSecurity.hasProjectRole(authentication, #request.projectId(), 'LEAD')")
    @DeleteMapping("/members/remove")
    public ResponseEntity<ApiResponse> removeMemberFromProject(@RequestBody RemoveMemberRequest request) {
        userProjectService.removeMemberFromProject(request);
        return ResponseEntity.ok(new ApiResponse(true, "Member removed successfully"));
    }

    // Verify that we can self remove (gives deletion code)
    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    @PostMapping("/self-remove/validate/{projectId}")
    public ResponseEntity<ApiResponse> validateSelfRemove(@PathVariable Long projectId, Authentication authentication) {
        return ResponseEntity.ok(new ApiResponse(true, "Validation successful", userProjectService.validateSelfRemove(projectId, authentication)));
    }

    /// THIS METHOD JUST DELETES, it is up to the frontend to validate before deleting/calling this method
    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    @DeleteMapping("/self-remove/{projectId}")
    public ResponseEntity<ApiResponse> selfRemoveFromProject(
            @PathVariable Long projectId,
            Authentication authentication
    ) {
        userProjectService.selfRemoveFromProject(projectId, authentication);
        return ResponseEntity.ok(new ApiResponse(true, "You have removed yourself successfully"));
    }

    ///  MERGE LOGIC USING NOTNULL AND NOTBLANKS (FIXED FOR UPDATE METHODS)

    ///  UPPERCASE STUFF IS HANDLED IN FRONTEND, BACKEND SIMPLY CAStS ENUMS WITHIN THE RECORDS
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\userproject\UserProjectId.java:
<code>
package com.brentcodes.springboot.librarysystem.userproject;

import jakarta.persistence.Embeddable;
import lombok.Data;

import java.io.Serializable;

@Data
@Embeddable
public class UserProjectId implements Serializable {
    private Long userId;
    private Long projectId;

    public UserProjectId() {
    }

    public UserProjectId(Long userId, Long projectId) { // used for creating relationships
        this.userId = userId;
        this.projectId = projectId;
    }
    // equals, hashCode
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\userproject\UserProjectRepository.java:
<code>
package com.brentcodes.springboot.librarysystem.userproject;

import aj.org.objectweb.asm.commons.Remapper;
import com.brentcodes.springboot.librarysystem.project.Project;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;
import java.util.Optional;

public interface UserProjectRepository extends JpaRepository<UserProject, UserProjectId> {
    Optional<UserProject> findByUserIdAndProjectId(Long userId, Long projectId);

    List<UserProject> findByUserId(Long userId);

    List<UserProject> findAllByProjectId(Long projectId);

    long countByProject(Project project);

}





</code>

src\main\java\com\brentcodes\springboot\librarysystem\userproject\UserProjectService.java:
<code>
package com.brentcodes.springboot.librarysystem.userproject;

import com.brentcodes.springboot.librarysystem.project.Project;
import com.brentcodes.springboot.librarysystem.project.ProjectRepository;
import com.brentcodes.springboot.librarysystem.user.User;
import com.brentcodes.springboot.librarysystem.user.UserPrincipal;
import com.brentcodes.springboot.librarysystem.user.UserRepository;
import com.brentcodes.springboot.librarysystem.uservulnerability.RoleInVuln;
import com.brentcodes.springboot.librarysystem.uservulnerability.UserVulnerability;
import com.brentcodes.springboot.librarysystem.uservulnerability.UserVulnerabilityRepository;
import com.brentcodes.springboot.librarysystem.vulnerability.VulnStatus;
import com.brentcodes.springboot.librarysystem.vulnerability.Vulnerability;
import com.brentcodes.springboot.librarysystem.vulnerability.VulnerabilityRepository;
import jakarta.persistence.EntityNotFoundException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class UserProjectService {

    private final UserProjectRepository userProjectRepository;
    private final UserVulnerabilityRepository userVulnerabilityRepository;
    private final VulnerabilityRepository vulnerabilityRepository;

    // A lot of these imports of userRepo and projectRepo are for checking existence of a user or project
    private final UserRepository userRepository;
    private final ProjectRepository projectRepository;

    public UserProjectService(UserProjectRepository userProjectRepository, UserVulnerabilityRepository userVulnerabilityRepository,UserRepository userRepository,  VulnerabilityRepository vulnerabilityRepository, ProjectRepository projectRepository) {
        this.userProjectRepository = userProjectRepository;
        this.userVulnerabilityRepository = userVulnerabilityRepository;
        this.userRepository = userRepository;
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.projectRepository = projectRepository;
    }

    @Transactional(readOnly = true)
    public List<ProjectSummaryDto> getMyProjects(Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();


        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserProject links
        return userProjectRepository.findByUserId(userId).stream()
                .map(link -> {
                    Project p = link.getProject();
                    return new ProjectSummaryDto(
                            p.getId(),
                            p.getName(),
                            p.getDescription(),
                            p.getCreatedAt(),
                            p.getUpdatedAt(),
                            link.getRole().name()
                    );
                })
                .toList();
    }

    // Get one of MY Projects by Id
    @Transactional(readOnly = true)
    public ProjectSummaryDto getMyProjectById(Authentication authentication, Long projectId) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        UserProject userProject = userProjectRepository
                .findByUserIdAndProjectId(userId, projectId)
                .orElseThrow(() -> new EntityNotFoundException("Project not found for this user"));

        Project p = userProject.getProject();

        return new ProjectSummaryDto(
                p.getId(),
                p.getName(),
                p.getDescription(),
                p.getCreatedAt(),
                p.getUpdatedAt(),
                userProject.getRole().name()
        );
    }

    // Get my Projects by name (may be overlap)
    @Transactional(readOnly = true)
    public List<ProjectSummaryDto> getMyProjectByName(Authentication authentication, String name) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        List<ProjectSummaryDto> results = userProjectRepository.findByUserId(userId).stream()
                .filter(link -> link.getProject().getName().equalsIgnoreCase(name))
                .map(link -> {
                    Project p = link.getProject();
                    return new ProjectSummaryDto(
                            p.getId(),
                            p.getName(),
                            p.getDescription(),
                            p.getCreatedAt(),
                            p.getUpdatedAt(),
                            link.getRole().name()
                    );
                })
                .toList();

        if (results.isEmpty()) {
            throw new EntityNotFoundException("No projects found with name: " + name);
        }

        return results;
    }

    @Transactional
    public RoleCheckerResponse changeUserRoleInProject(ChangeProjectRoleCommand request) {
        Long projectId = request.projectId();
        Long userId = request.userId();

        // 1. Validate that the user exists
        userRepository.findById(userId)
                .orElseThrow(() -> new EntityNotFoundException("User not found"));

        // 2. Validate they are part of the project
        UserProject userProject = userProjectRepository.findByUserIdAndProjectId(userId, projectId)
                .orElseThrow(() -> new IllegalStateException("User is not part of this project"));

        ProjectRole oldRole = userProject.getRole();
        ProjectRole newRole = request.newRole();

        // 3. If the role isn't changing, bail out
        if (oldRole == newRole) {
            throw new IllegalStateException("User already has this project role");
        }

        // 4. If demoting (e.g., PROGRAMMER -> TESTER), clean up their vuln assignments
        if (oldRole == ProjectRole.PROGRAMMER && newRole == ProjectRole.TESTER) {
            // Find all ASSIGNEE vuln links for this user in this project
            List<UserVulnerability> assigneeLinks =
                    userVulnerabilityRepository.findByUserIdAndVulnerabilityProjectIdAndRole(userId, projectId, RoleInVuln.ASSIGNEE);

            for (UserVulnerability link : assigneeLinks) {
                Vulnerability vuln = link.getVulnerability();

                // Remove the assignee link
                userVulnerabilityRepository.delete(link);

                // If no other assignees exist, revert vuln status to REPORTED
                boolean hasOtherAssignees = userVulnerabilityRepository
                        .existsByVulnerabilityIdAndRole(vuln.getId(), RoleInVuln.ASSIGNEE);
                if (!hasOtherAssignees && vuln.getStatus() == VulnStatus.IN_PROGRESS) {
                    vuln.setStatus(VulnStatus.REPORTED);
                    vuln.setUpdatedAt(Instant.now());
                    vulnerabilityRepository.save(vuln);
                }
            }
        }

        // 5. If promoting TESTER -> PROGRAMMER, no cleanup needed
        if (oldRole == ProjectRole.TESTER && newRole == ProjectRole.PROGRAMMER) {
            // Find all VERIFIER vuln links for this user in this project
            List<UserVulnerability> verifierLinks =
                    userVulnerabilityRepository.findByUserIdAndVulnerabilityProjectIdAndRole(userId, projectId, RoleInVuln.VERIFIER);

            for (UserVulnerability link : verifierLinks) {
                Vulnerability vuln = link.getVulnerability();

                // Remove the verifier link
                userVulnerabilityRepository.delete(link);

                // If no other assignees exist, revert vuln status to IN_PROGRESS
                boolean hasOtherVerifiers = userVulnerabilityRepository
                        .existsByVulnerabilityIdAndRole(vuln.getId(), RoleInVuln.VERIFIER);
                if (!hasOtherVerifiers && vuln.getStatus() == VulnStatus.UNDER_REVIEW) {
                    vuln.setStatus(VulnStatus.IN_PROGRESS);
                    vuln.setUpdatedAt(Instant.now());
                    vulnerabilityRepository.save(vuln);
                }

                // If the vuln status is "Verified" nothing has to happen since the task it out of control
            }
        }

        // 6. If demoting from LEAD, clean up roles based on new role permissions
        if (oldRole == ProjectRole.LEAD && newRole != ProjectRole.LEAD) {
            // LEADs can have both ASSIGNEE and VERIFIER roles, so we need to check both

            // Get all ASSIGNEE links
            List<UserVulnerability> assigneeLinks =
                    userVulnerabilityRepository.findByUserIdAndVulnerabilityProjectIdAndRole(userId, projectId, RoleInVuln.ASSIGNEE);

            // Get all VERIFIER links
            List<UserVulnerability> verifierLinks =
                    userVulnerabilityRepository.findByUserIdAndVulnerabilityProjectIdAndRole(userId, projectId, RoleInVuln.VERIFIER);

            // If demoting to TESTER, remove all ASSIGNEE roles
            if (newRole == ProjectRole.TESTER) {
                for (UserVulnerability link : assigneeLinks) {
                    Vulnerability vuln = link.getVulnerability();

                    // Remove the assignee link
                    userVulnerabilityRepository.delete(link);

                    // If no other assignees exist, revert vuln status to REPORTED
                    boolean hasOtherAssignees = userVulnerabilityRepository
                            .existsByVulnerabilityIdAndRole(vuln.getId(), RoleInVuln.ASSIGNEE);
                    if (!hasOtherAssignees && vuln.getStatus() == VulnStatus.IN_PROGRESS) {
                        vuln.setStatus(VulnStatus.REPORTED);
                        vuln.setUpdatedAt(Instant.now());
                        vulnerabilityRepository.save(vuln);
                    }
                }
                // Keep VERIFIER roles (TESTERs can be VERIFIERs)
            }

            // If demoting to PROGRAMMER, remove all VERIFIER roles
            if (newRole == ProjectRole.PROGRAMMER) {
                for (UserVulnerability link : verifierLinks) {
                    Vulnerability vuln = link.getVulnerability();

                    // Remove the verifier link
                    userVulnerabilityRepository.delete(link);

                    // If no other verifiers exist, revert vuln status to IN_PROGRESS
                    boolean hasOtherVerifiers = userVulnerabilityRepository
                            .existsByVulnerabilityIdAndRole(vuln.getId(), RoleInVuln.VERIFIER);
                    if (!hasOtherVerifiers && vuln.getStatus() == VulnStatus.UNDER_REVIEW) {
                        vuln.setStatus(VulnStatus.IN_PROGRESS);
                        vuln.setUpdatedAt(Instant.now());
                        vulnerabilityRepository.save(vuln);
                    }
                }
                // Keep ASSIGNEE roles (PROGRAMMERs can be ASSIGNEEs)
            }
        }

        // Only show warning if promoting to LEAD
        if (newRole == ProjectRole.LEAD) {
            return new RoleCheckerResponse(
                    true,
                    "You are about to promote this user to LEAD. This will add an additional project lead.",
                    "PROMOTING_MEMBER_LEAD"
            );
        }

        // 6. Update project role
        userProject.setRole(newRole);
        userProjectRepository.save(userProject);
        return new RoleCheckerResponse(false, null);
    }


    public List<ProjectMemberResponse> getProjectMembers(Long projectId) {
        return userProjectRepository.findAllByProjectId(projectId)
                .stream()
                .map(up -> new ProjectMemberResponse(
                        up.getUser().getId(),
                        up.getUser().getFirstname(),
                        up.getUser().getLastname(),
                        up.getRole()   // ‚úÖ THIS IS THE PROJECT ROLE
                ))
                .toList();
    }

    @Transactional
    public RoleCheckerResponse addMemberToProject(AddMemberRequest request) {
        Project project = projectRepository.findById(request.projectId())
                .orElseThrow(() -> new IllegalArgumentException("Project not found"));

        User user = userRepository.findById(request.userId())
                .orElseThrow(() -> new IllegalArgumentException("User not found"));

        // Prevent duplicate membership
        boolean alreadyMember = userProjectRepository.findByUserIdAndProjectId(user.getId(), request.projectId()).isPresent();
        if (alreadyMember) {
            throw new IllegalStateException("User is already a member of this project");
        }

        ProjectRole role = request.role();

        if (role == ProjectRole.LEAD) {
            return new RoleCheckerResponse(
                    true,
                    "You are adding a new LEAD to this project. This will grant them full permissions.",
                    "ADDING_MEMBER_LEAD"
            );
        }

        UserProject userProject = new UserProject();
        userProject.setUser(user);
        userProject.setProject(project);
        userProject.setRole(role);

        userProjectRepository.save(userProject);
        return new RoleCheckerResponse(
                false,
                "Member successfully added."
        );
    }

    @Transactional(readOnly = true)
    public RoleCheckerResponse validateRemoveMember(RemoveMemberRequest request) {
        Long userId = request.userId();
        Long projectId = request.projectId();

        UserProject userProject = userProjectRepository
                .findByUserIdAndProjectId(userId, projectId)
                .orElseThrow(() -> new IllegalArgumentException("User is not a member of this project"));

        ProjectRole removedRole = userProject.getRole();

        List<UserProject> remainingMembers =
                userProjectRepository.findAllByProjectId(projectId)
                        .stream()
                        .filter(up -> !up.getUser().getId().equals(userId))
                        .toList();

        // Last LEAD?
        if (removedRole == ProjectRole.LEAD) {
            boolean hasOtherLeads = remainingMembers.stream()
                    .anyMatch(up -> up.getRole() == ProjectRole.LEAD);

            if (!hasOtherLeads) {
                return new RoleCheckerResponse(
                        true,
                        "Removing this member will leave the project without a lead.",
                        "REMOVING_MEMBER_LEAD"
                );
            }
        }

        // Safe ‚Üí return "SAFE_TO_DELETE"
        return new RoleCheckerResponse(false, "SAFE_TO_DELETE");
    }

    @Transactional
    public void removeMemberFromProject(RemoveMemberRequest request) {
        // Delete UserProject links (membership info)
        UserProject link = userProjectRepository
                .findByUserIdAndProjectId(request.userId(), request.projectId())
                .orElseThrow(() -> new IllegalArgumentException("User not in project"));

        // Delete all UserVulnerability assignments for this user in this project
        userVulnerabilityRepository.deleteAllAssignmentsForUserInProject(
                request.userId(),
                request.projectId()
        );

        userProjectRepository.delete(link);
    }

    @Transactional(readOnly = true)
    public RoleCheckerResponse validateSelfRemove(Long projectId, Authentication auth) {

        Long userId = ((UserPrincipal) auth.getPrincipal()).getId();

        UserProject userProject = userProjectRepository
                .findByUserIdAndProjectId(userId, projectId)
                .orElseThrow(() -> new IllegalArgumentException("You are not a member of this project"));

        ProjectRole role = userProject.getRole();

        List<UserProject> remainingMembers =
                userProjectRepository.findAllByProjectId(projectId)
                        .stream()
                        .filter(up -> !up.getUser().getId().equals(userId))
                        .toList();

        // Last member (deleting project)?
        if (remainingMembers.isEmpty()) {
            return new RoleCheckerResponse(
                    true,
                    "You are the last member. Leaving will delete the project.",
                    "SELF_REMOVE_LAST_MEMBER"
            );
        }

        // Last LEAD?
        boolean hasOtherLeads = remainingMembers.stream()
                .anyMatch(up -> up.getRole() == ProjectRole.LEAD);

        if (role == ProjectRole.LEAD && !hasOtherLeads) {
            return new RoleCheckerResponse(
                    true,
                    "You are the last lead. Promote another member first.",
                    "SELF_REMOVE_LAST_LEAD"
            );
        }

        return new RoleCheckerResponse(false, "SAFE_TO_DELETE");
    }
    @Transactional
    public void selfRemoveFromProject(Long projectId, Authentication authentication) {
        Long userId = ((UserPrincipal) authentication.getPrincipal()).getId();

        Project project = projectRepository.findById(projectId)
                .orElseThrow(() -> new EntityNotFoundException("Project not found with ID " + projectId));

        UserProject link = userProjectRepository
                .findByUserIdAndProjectId(userId, projectId)
                .orElseThrow(() -> new IllegalArgumentException("Not a member"));

        boolean isLead = link.getRole() == ProjectRole.LEAD;

        // Count how many members exist in this project
        long totalMembers = userProjectRepository.countByProject(project);

        // --------------------------------------------
        // CASE 1 ‚Üí NON-LEAD MEMBER SELF-REMOVAL
        // --------------------------------------------
        if (!isLead) {

            // Remove them from project membership
            userProjectRepository.delete(link);

            // Remove their vulnerability assignments
            userVulnerabilityRepository.deleteAllAssignmentsForUserInProject(userId, projectId);

            return; // DONE ‚Äî project stays alive
        }

        // --------------------------------------------
        // CASE 2 ‚Üí LEAD SELF-REMOVAL
        // --------------------------------------------

        // Remove the lead from the project
        userProjectRepository.delete(link);

        // Remove their vulnerability assignments
        userVulnerabilityRepository.deleteAllAssignmentsForUserInProject(userId, projectId);

        // If they were the ONLY member left, safely delete entire project
        if (totalMembers == 1) {
            projectRepository.delete(project);
        }

        // Otherwise, just remove the lead ‚Äî project lives
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\uservulnerability\RoleInVuln.java:
<code>
package com.brentcodes.springboot.librarysystem.uservulnerability;

public enum RoleInVuln {
    REPORTER, // Can only view code (not auto assigned if reported something)
    ASSIGNEE, // Can edit stuff and copy code
    VERIFIER // Can only confirm code
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\uservulnerability\UserProjectRelationshipRequest.java:
<code>
package com.brentcodes.springboot.librarysystem.uservulnerability;

import jakarta.validation.constraints.NotNull;
import org.springframework.lang.NonNull;

public record UserProjectRelationshipRequest(
        @NotNull Long userId,
        @NotNull Long projectId
) {
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\uservulnerability\UserVulnerability.java:
<code>
package com.brentcodes.springboot.librarysystem.uservulnerability;

import com.brentcodes.springboot.librarysystem.vulnerability.Vulnerability;
import com.brentcodes.springboot.librarysystem.user.User;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;
import java.util.Objects;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "user_vulnerability")
public class UserVulnerability {
    // creates composite key, boilerplate
    @EmbeddedId
    private UserVulnerabilityId id = new UserVulnerabilityId(); // tomfoolery

    // MapsId takes the ID from the student and the ID from the vulnerability, and combine them to create the primary key for this record.
    // This primary key is also called the composite key in this context (merges the two primary/foreign keys)
    // Foreign keys live in the combining table
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("userId") // create foreign key
    @JoinColumn(name = "user_id")
    @JsonIgnore
    private User user;

    // @MapsId will generate an embedded ID, no need for sequence generation or instantiation in constructor
    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("vulnerabilityId") // boilerplate, references the UserVulnerabilityId composite create
    @JoinColumn(name = "vulnerability_id")
    @JsonIgnore
    private Vulnerability vulnerability;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private RoleInVuln role; // REPORTER, ASSIGNEE, VERIFIER

    @Column(nullable = false)
    private Instant assignedAt;

    private boolean selfAssigned;

    private Instant completedAt; // When it is verified and everything else is done (implied)

    // Only for seeding (without id)
    public UserVulnerability(User user, Vulnerability vulnerability, RoleInVuln role,
                             Instant assignedAt, boolean selfAssigned, Instant completedAt) {
        this.user = user;
        this.vulnerability = vulnerability;
        this.role = role;
        this.assignedAt = assignedAt;
        this.selfAssigned = selfAssigned;
        this.completedAt = completedAt;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof UserVulnerability)) return false;
        UserVulnerability other = (UserVulnerability) o;
        return id != null && id.equals(other.id);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(id);
    }
}


</code>

src\main\java\com\brentcodes\springboot\librarysystem\uservulnerability\UserVulnerabilityController.java:
<code>
package com.brentcodes.springboot.librarysystem.uservulnerability;

import com.brentcodes.springboot.librarysystem.backendconfig.ApiResponse;
import com.brentcodes.springboot.librarysystem.backendconfig.GlobalExceptionHandler;
import com.brentcodes.springboot.librarysystem.user.User;
import com.brentcodes.springboot.librarysystem.vulnerability.Vulnerability;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/uservulns")
public class UserVulnerabilityController {

    private final UserVulnerabilityService userVulnerabilityService;

    public UserVulnerabilityController(UserVulnerabilityService userVulnerabilityService, GlobalExceptionHandler globalExceptionHandler) {
        this.userVulnerabilityService = userVulnerabilityService;
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #selfAssign.projectId())")
    // Anyone can access this (we pass project and vuln id's for checks)
    @PostMapping("/self-assign")
    public ResponseEntity<ApiResponse> selfAssignToVulnerability(@RequestBody VulnerabilitySelfAssignRevoke selfAssign, Authentication auth) {
        userVulnerabilityService.selfAssignToVulnerability(selfAssign, auth);
        return ResponseEntity.ok(new ApiResponse(true, "You have assigned yourself to this vulnerability"));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #selfRevoke.projectId())")
    // Anyone can access this
    @DeleteMapping("/self-revoke")
    public ResponseEntity<ApiResponse> selfRevokeFromVulnerability(@RequestBody VulnerabilitySelfAssignRevoke selfRevoke, Authentication auth) {
        userVulnerabilityService.selfRevokeFromVulnerability(selfRevoke, auth);
        return ResponseEntity.ok(new ApiResponse(true, "You have withdrawn yourself from this vulnerability"));
    }

    // Only for project leads. Allows them to assign a member to a vuln (and gives them the role for that vuln... should also update vuln status)
    @PreAuthorize("@projectSecurity.hasProjectRole(authentication, #vulnerabilityAssignAction.projectId(), 'LEAD')")
    @PostMapping("/assign")
    public ResponseEntity<ApiResponse> assignUserToVulnerability(
            @RequestBody VulnerabilityAssignAction vulnerabilityAssignAction
    ) {
        User user = userVulnerabilityService.assignUserToVulnerability(vulnerabilityAssignAction);
        return ResponseEntity.ok(new ApiResponse(true,
                "User " + user.getFirstname() + " was assigned as " + vulnerabilityAssignAction.role() + " within the project successfully"));
    }

    // Unassign a user from a role (Project Lead) command... maybe update the vuln status?
    @PreAuthorize("@projectSecurity.hasProjectRole(authentication, #vulnerabilityRevokeAction.projectId(), 'LEAD')")
    @DeleteMapping("/unassign")
    public ResponseEntity<ApiResponse> revokeUserFromVulnerability(
            @RequestBody VulnerabilityRevokeAction vulnerabilityRevokeAction
    ) {
        User user = userVulnerabilityService.revokeUserFromVulnerability(vulnerabilityRevokeAction);
        return ResponseEntity.ok(new ApiResponse(true,
                "User " + user.getFirstname() + " was unassigned successfully"));
    }

    /** Global Scoped */
    @GetMapping("/reported")
    public ResponseEntity<ApiResponse> getAllReportedByMe(Authentication authentication) {
        List<Vulnerability> reported = userVulnerabilityService.getReportedByMe(authentication);
        if (reported.isEmpty()) {
            return ResponseEntity.ok(new ApiResponse(true, "Wow, such empty üê∂", reported));
        }
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities successfully returned", reported));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    @GetMapping("/reported/{projectId}")
    public ResponseEntity<ApiResponse> getReportedByMeInProject(@PathVariable Long projectId, Authentication authentication) {
        List<Vulnerability> reported = userVulnerabilityService.getReportedByMeInProject(projectId,  authentication);
        if (reported.isEmpty()) {
            return ResponseEntity.ok(new ApiResponse(true, "Wow, such empty üê∂", reported));
        }
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities successfully returned", reported));
    }

    /** Global Scoped */
    @GetMapping("/assigned")
    public ResponseEntity<ApiResponse> getAssignedToMe(Authentication authentication) {
        List<Vulnerability> assigned = userVulnerabilityService.getAssignedToMe(authentication);
        if (assigned.isEmpty()) {
            return ResponseEntity.ok(new ApiResponse(true, "Wow, such empty üê∂", assigned));
        }
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities successfully returned", assigned));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    @GetMapping("/assigned/{projectId}")
    public ResponseEntity<ApiResponse> getAssignedToMeInProject(@PathVariable Long projectId, Authentication authentication) {
        List<Vulnerability> assigned = userVulnerabilityService.getAssignedToMeInProject(projectId,  authentication);
        if (assigned.isEmpty()) {
            return ResponseEntity.ok(new ApiResponse(true, "Wow, such empty üê∂", assigned));
        }
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities successfully returned", assigned));
    }

    /** Global Scoped */
    @GetMapping("/verified")
    public ResponseEntity<ApiResponse> getVerifiedByMe(Authentication authentication) {
        List<Vulnerability> verified = userVulnerabilityService.getVerifiedByMe(authentication);
        if (verified.isEmpty()) {
            return ResponseEntity.ok(new ApiResponse(true, "Wow, such empty üê∂", verified));
        }
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities successfully returned", verified));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    @GetMapping("/verified/{projectId}")
    public ResponseEntity<ApiResponse> getVerifiedByMeInProject(@PathVariable Long projectId, Authentication authentication) {
        List<Vulnerability> verified = userVulnerabilityService.getVerifiedByMeInProject(projectId,  authentication);
        if (verified.isEmpty()) {
            return ResponseEntity.ok(new ApiResponse(true, "Wow, such empty üê∂", verified));
        }
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities successfully returned", verified));
    }

    // I can also create a sort method that filters by created at in the front end (sort order)
    // This would return an ordered list that would be pasted in the front end
    // getMostRecentlyAssigned to me and more stuff


    // üîê Lead: Find all reports created by a user
    @PreAuthorize("@projectSecurity.hasProjectRole(authentication, #request.projectId(), 'LEAD')")
    @GetMapping("/reported-by-user")
    // ‚ÄúTake the value from the {userId} part of the URL and assign it to this parameter.‚Äù
    public ResponseEntity<ApiResponse> getReportedByUserInProject(@RequestBody UserProjectRelationshipRequest request) {
        List<Vulnerability> reported = userVulnerabilityService.getReportedByUserInProject(request);
        if (reported.isEmpty()) {
            return ResponseEntity.ok(new ApiResponse(true, "Wow, such empty üê∂", reported));
        }
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities successfully returned", reported));
    }

    // üîê Lead: Find all assigned vulns to user
    @PreAuthorize("@projectSecurity.hasProjectRole(authentication, #request.projectId(), 'LEAD')")
    @GetMapping("/assigned-to-user")
    // ‚ÄúTake the value from the {userId} part of the URL and assign it to this parameter.‚Äù
    public ResponseEntity<ApiResponse> getAssignedToUserInProject(@RequestBody UserProjectRelationshipRequest request) {
        List<Vulnerability> assigned = userVulnerabilityService.getAssignedToUserInProject(request);
        if (assigned.isEmpty()) {
            return ResponseEntity.ok(new ApiResponse(true, "Wow, such empty üê∂", assigned));
        }
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities successfully returned", assigned));
    }

    // üîê Lead: Find all vulns verified by a user
    @PreAuthorize("@projectSecurity.hasProjectRole(authentication, #request.projectId(), 'LEAD')")
    @GetMapping("/verified-by-user")
    // ‚ÄúTake the value from the {userId} part of the URL and assign it to this parameter.‚Äù
    public ResponseEntity<ApiResponse> getVerifiedByUserInProject(@RequestBody UserProjectRelationshipRequest request) {
        List<Vulnerability> verified = userVulnerabilityService.getVerifiedByUserInProject(request);
        if (verified.isEmpty()) {
            return ResponseEntity.ok(new ApiResponse(true, "Wow, such empty üê∂", verified));
        }
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities successfully returned", verified));
    }


}


</code>

src\main\java\com\brentcodes\springboot\librarysystem\uservulnerability\UserVulnerabilityId.java:
<code>
package com.brentcodes.springboot.librarysystem.uservulnerability;

import jakarta.persistence.Embeddable;
import lombok.Data;

import java.io.Serializable;

// Acts as a composite key for the join table "UserVulnerability"
@Data
@Embeddable
public class UserVulnerabilityId implements Serializable {
    private Long userId;
    private Long vulnerabilityId;

    public UserVulnerabilityId() {
    }

    public UserVulnerabilityId(Long userId, Long vulnerabilityId) {
        this.userId = userId;
        this.vulnerabilityId = vulnerabilityId;
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\uservulnerability\UserVulnerabilityRepository.java:
<code>
package com.brentcodes.springboot.librarysystem.uservulnerability;

import com.brentcodes.springboot.librarysystem.user.Role;
import com.brentcodes.springboot.librarysystem.vulnerability.Vulnerability;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;
import java.util.List;
import java.util.Optional;

// In this order, the repository managed the UserVulnerability table and its primary key is UserVulnerabilityId
// The first parameter is the entity im working with while the other is the primary key the entity uses
public interface UserVulnerabilityRepository extends JpaRepository<UserVulnerability, UserVulnerabilityId> {

    // All of these are implemented for UserVulnerabilityService and that class only
    List<UserVulnerability> findByUserId(@Param("userId") Long userId);

    List<UserVulnerability> findByUserIdAndRole(Long userId, RoleInVuln role);

    Optional<UserVulnerability> findByUserIdAndVulnerabilityId(Long userId, Long vulnId);

    boolean existsByUserIdAndVulnerabilityIdAndRole(Long userId, Long vulnerabilityId, RoleInVuln role);

    boolean existsByVulnerabilityIdAndRole(Long vulnId, RoleInVuln roleInVuln);

    List<UserVulnerability> findByUserIdAndVulnerabilityProjectIdAndRole(Long userId, Long vulnerabilityProjectId, RoleInVuln role);

    @Modifying
    @Transactional
    @Query("""
    DELETE FROM UserVulnerability uv
    WHERE uv.user.id = :userId
      AND uv.vulnerability.project.id = :projectId
""")
    void deleteAllAssignmentsForUserInProject(Long userId, Long projectId);
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\uservulnerability\UserVulnerabilityService.java:
<code>
package com.brentcodes.springboot.librarysystem.uservulnerability;

import com.brentcodes.springboot.librarysystem.userproject.ProjectRole;
import com.brentcodes.springboot.librarysystem.userproject.ProjectSecurity;
import com.brentcodes.springboot.librarysystem.userproject.UserProject;
import com.brentcodes.springboot.librarysystem.userproject.UserProjectRepository;
import com.brentcodes.springboot.librarysystem.vulnerability.VulnStatus;
import com.brentcodes.springboot.librarysystem.vulnerability.Vulnerability;
import com.brentcodes.springboot.librarysystem.vulnerability.VulnerabilityRepository;
import com.brentcodes.springboot.librarysystem.user.User;
import com.brentcodes.springboot.librarysystem.user.UserPrincipal;
import com.brentcodes.springboot.librarysystem.user.UserRepository;
import jakarta.persistence.EntityNotFoundException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.RequestBody;

import java.time.Instant;
import java.util.List;
import java.util.stream.Collectors;

// Responsible for user and vulnerability logic (anything to do with their relationship) so that includes finding the books of a user
@Service
public class UserVulnerabilityService {

    private final UserVulnerabilityRepository userVulnerabilityRepository;
    private final UserRepository userRepository;
    private final VulnerabilityRepository vulnerabilityRepository;
    private final ProjectSecurity projectSecurity;
    private final UserProjectRepository userProjectRepository;

    @Autowired // Not required for single constructors... depends on dependency injection
    public UserVulnerabilityService(UserVulnerabilityRepository userVulnerabilityRepository, UserRepository userRepository, VulnerabilityRepository vulnerabilityRepository,  ProjectSecurity projectSecurity,  UserProjectRepository userProjectRepository) {
        this.userVulnerabilityRepository = userVulnerabilityRepository;
        this.userRepository = userRepository;
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.projectSecurity = projectSecurity;
        this.userProjectRepository = userProjectRepository;
    }

    @Transactional
    public void selfAssignToVulnerability(VulnerabilitySelfAssignRevoke selfAssign, Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));


        Vulnerability vuln = vulnerabilityRepository.getVulnerabilitiesById(selfAssign.vulnId());

        // Make sure the user is a member of the project
        userProjectRepository.findByUserIdAndProjectId(user.getId(), selfAssign.projectId())
                .map(UserProject::getRole)
                .orElseThrow(() -> new AccessDeniedException("User is not a member of this project"));


        // Prevent Duplicates
        UserVulnerabilityId id = new UserVulnerabilityId(user.getId(), vuln.getId());
        if (userVulnerabilityRepository.existsById(id)) {
            throw new IllegalStateException("You are already assigned to this vulnerability");
        }

        // Determine project role and map to RoleInVuln
        ProjectRole projectRole = projectSecurity.getProjectRole(authentication, vuln.getProject().getId());
        RoleInVuln roleInVuln = switch (projectRole) {
            case PROGRAMMER, LEAD -> RoleInVuln.ASSIGNEE; // Members and leads become assignees
            case TESTER -> RoleInVuln.VERIFIER; // Testers become verifiers
            default -> throw new AccessDeniedException("You are not allowed to self-assign to this vulnerability");
        };

        // Link user and vulnerability with verified role
        UserVulnerability link = UserVulnerability.builder()
                .id(id)
                .user(user)
                .vulnerability(vuln)
                .role(roleInVuln)
                .selfAssigned(true) // optional but good for clarity
                .assignedAt(Instant.now()) // optional audit info
                .build();

        //noinspection DuplicatedCode
        userVulnerabilityRepository.save(link);

        // Update vulnerability status depending on role
        switch (roleInVuln) {
            case ASSIGNEE -> {
                if (vuln.getStatus() == VulnStatus.REPORTED) {
                    vuln.setStatus(VulnStatus.IN_PROGRESS);
                    vuln.setUpdatedAt(Instant.now());
                }
            }
            case VERIFIER -> {
                if (vuln.getStatus() == VulnStatus.PATCHED) {
                    vuln.setStatus(VulnStatus.UNDER_REVIEW);
                    vuln.setUpdatedAt(Instant.now());
                }
            }
        }
        // Save the vuln with updated state
        vulnerabilityRepository.save(vuln);
    }

    @Transactional
    public void selfRevokeFromVulnerability(VulnerabilitySelfAssignRevoke selfRevoke, Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        Vulnerability vuln = vulnerabilityRepository.getVulnerabilitiesById(selfRevoke.vulnId());

        Long projectId = vuln.getProject().getId();

        // Ensure the user is a member of the project
        userProjectRepository.findByUserIdAndProjectId(user.getId(), projectId)
                .orElseThrow(() -> new AccessDeniedException("User is not a member of this project"));

        // Get the existing UserVulnerability link
        UserVulnerability link = userVulnerabilityRepository
                .findByUserIdAndVulnerabilityId(user.getId(), vuln.getId())
                .orElseThrow(() -> new IllegalStateException("You are not assigned to this vulnerability"));

        RoleInVuln roleInVuln = link.getRole();

        // Delete the link (self unassign)
        userVulnerabilityRepository.delete(link);

        // 5Ô∏è‚É£ Update vulnerability status depending on the role revoked
        switch (roleInVuln) {
            case ASSIGNEE -> {
                boolean hasOtherAssignees = userVulnerabilityRepository
                        .existsByVulnerabilityIdAndRole(selfRevoke.vulnId(), RoleInVuln.ASSIGNEE);
                if (!hasOtherAssignees && vuln.getStatus() == VulnStatus.IN_PROGRESS) {
                    vuln.setStatus(VulnStatus.REPORTED);
                    vuln.setUpdatedAt(Instant.now());
                }
            }
            case VERIFIER -> {
                boolean hasOtherVerifiers = userVulnerabilityRepository
                        .existsByVulnerabilityIdAndRole(selfRevoke.vulnId(), RoleInVuln.VERIFIER);
                if (!hasOtherVerifiers && vuln.getStatus() == VulnStatus.UNDER_REVIEW) {
                    vuln.setStatus(VulnStatus.PATCHED);
                    vuln.setUpdatedAt(Instant.now());
                }
            }
        }

        // Save the vuln with updated state
        vulnerabilityRepository.save(vuln);
    }

    @Transactional
    public User assignUserToVulnerability(VulnerabilityAssignAction action) {
        // 1. Look up entities
        Vulnerability vuln = vulnerabilityRepository.findById(action.vulnId())
                .orElseThrow(() -> new EntityNotFoundException("Vulnerability not found"));

        User user = userRepository.findById(action.userId())
                .orElseThrow(() -> new EntityNotFoundException("User not found"));

        Long projectId = vuln.getProject().getId();

        // Ensure the user being assigned is a member of the project
        ProjectRole projectRole = userProjectRepository
                .findByUserIdAndProjectId(user.getId(), projectId)
                .map(UserProject::getRole)
                .orElseThrow(() -> new AccessDeniedException("User is not a member of this project"));

        RoleInVuln vulnRole = action.role();

        // Prevent Duplicates
        UserVulnerabilityId id = new UserVulnerabilityId(user.getId(), vuln.getId());
        if (userVulnerabilityRepository.existsById(id)) {
            throw new IllegalStateException("You are already assigned to this vulnerability");
        }

        // Validate the user's Project Role is allowed to take on the RoleInVuln thing
        switch (projectRole) {
            case PROGRAMMER -> {
                if (vulnRole != RoleInVuln.ASSIGNEE) {
                    throw new IllegalArgumentException("Programmers can only be assigned as ASSIGNEE");
                }
            }
            case TESTER -> {
                if (vulnRole != RoleInVuln.VERIFIER) {
                    throw new IllegalArgumentException("Testers can only be assigned as VERIFIER");
                }
            }
            case LEAD -> {
                // Leads can be assigned any role
            }
            default -> throw new AccessDeniedException("Unknown project role");
        }

        // Link user and vulnerability with verified role
        UserVulnerability link = UserVulnerability.builder()
                .id(id)
                .user(user)
                .vulnerability(vuln)
                .role(vulnRole)
                .assignedAt(Instant.now()) // optional audit info
                .build();

        //noinspection DuplicatedCode
        userVulnerabilityRepository.save(link);

        // Update vulnerability status depending on role
        switch (vulnRole) {
            case ASSIGNEE -> {
                if (vuln.getStatus() == VulnStatus.REPORTED) {
                    vuln.setStatus(VulnStatus.IN_PROGRESS);
                    vuln.setUpdatedAt(Instant.now());
                }
            }
            case VERIFIER -> {
                if (vuln.getStatus() == VulnStatus.PATCHED) {
                    vuln.setStatus(VulnStatus.UNDER_REVIEW);
                    vuln.setUpdatedAt(Instant.now());
                }
            }
        }
        vulnerabilityRepository.save(vuln);
        return user;
    }

    // Revoke a user from a vulnerability role
    @Transactional
    public User revokeUserFromVulnerability(VulnerabilityRevokeAction action) {
        Vulnerability vuln = vulnerabilityRepository.findById(action.vulnId())
                .orElseThrow(() -> new EntityNotFoundException("Vulnerability not found"));

        User user = userRepository.findById(action.userId())
                .orElseThrow(() -> new EntityNotFoundException("User not found"));

        // 1. Fetch the UserVulnerability link
        UserVulnerability link = userVulnerabilityRepository.findByUserIdAndVulnerabilityId(action.userId(), action.vulnId())
                .orElseThrow(() -> new EntityNotFoundException("User is not assigned to this vulnerability"));

        // Get the users role in the vulnerability
        RoleInVuln role = link.getRole();

        // 2. Remove the link
        userVulnerabilityRepository.delete(link);

        // 3. If the role is ASSIGNEE and no more assignees remain, revert vuln status
        if (role == RoleInVuln.ASSIGNEE) {
            boolean hasOtherAssignees = userVulnerabilityRepository.existsByVulnerabilityIdAndRole(action.vulnId(), RoleInVuln.ASSIGNEE);
            if (!hasOtherAssignees && vuln.getStatus() == VulnStatus.IN_PROGRESS) {
                vuln.setStatus(VulnStatus.REPORTED);
                vuln.setReportedAt(null);
            }
        }

        // 4. If the role is VERIFIER and no more verifiers remain, revert vuln status
        if (role == RoleInVuln.VERIFIER) {
            boolean hasOtherVerifiers = userVulnerabilityRepository
                    .existsByVulnerabilityIdAndRole(action.vulnId(), RoleInVuln.VERIFIER);

            if (!hasOtherVerifiers && vuln.getStatus() == VulnStatus.UNDER_REVIEW) {
                vuln.setStatus(VulnStatus.PATCHED);
            }
        }
        vulnerabilityRepository.save(vuln);
        return user;
    }


    public List<Vulnerability> getReportedByMe(Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();


        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was a REPORTER (not user vs admin because we are accessing uservuln defined role)
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(userId, RoleInVuln.REPORTER);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .collect(Collectors.toList()); // return mutable (modifiable list) doesn't really matter in this case
    }

    public List<Vulnerability> getReportedByMeInProject(Long projectId, Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was a REPORTER (not user vs admin because we are accessing uservuln defined role)
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(userId, RoleInVuln.REPORTER);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .filter(v -> v.getProject().getId().equals(projectId))  // ‚úÖ filter by project
                .collect(Collectors.toList());
    }

    @Transactional
    public List<Vulnerability> getAssignedToMe(Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Same stuff as above but just shortened
        return userVulnerabilityRepository.findByUserIdAndRole(userId, RoleInVuln.ASSIGNEE).stream()
                .map(UserVulnerability::getVulnerability) // unwrap the Vulnerability entity from join table (better to do it in service than the repo to maintain consistency)
                .toList();
    }

    public List<Vulnerability> getAssignedToMeInProject(Long projectId, Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();


        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was an ASSIGNEE
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(userId, RoleInVuln.ASSIGNEE);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .filter(v -> v.getProject().getId().equals(projectId))  // ‚úÖ filter by project
                .collect(Collectors.toList());
    }

    @Transactional
    public List<Vulnerability> getVerifiedByMe(Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Same stuff as above but just shortened
        return userVulnerabilityRepository.findByUserIdAndRole(userId, RoleInVuln.VERIFIER).stream()
                .map(UserVulnerability::getVulnerability)
                .toList();
    }

    public List<Vulnerability> getVerifiedByMeInProject(Long projectId, Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();


        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was an ASSIGNEE
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(userId, RoleInVuln.VERIFIER);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .filter(v -> v.getProject().getId().equals(projectId))  // ‚úÖ filter by project
                .collect(Collectors.toList());
    }

    public List<Vulnerability> getReportedByUserInProject(UserProjectRelationshipRequest request) {
        userRepository.findById(request.userId())
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was a REPORTER (not user vs admin because we are accessing uservuln defined role)
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(request.userId(), RoleInVuln.REPORTER);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .filter(v -> v.getProject().getId().equals(request.projectId()))  // ‚úÖ filter by project
                .collect(Collectors.toList());
    }

    public List<Vulnerability> getAssignedToUserInProject(UserProjectRelationshipRequest request) {
        userRepository.findById(request.userId())
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was a ASSIGNEE (not user vs admin because we are accessing uservuln defined role)
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(request.userId(), RoleInVuln.ASSIGNEE);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .filter(v -> v.getProject().getId().equals(request.projectId()))  // ‚úÖ filter by project
                .collect(Collectors.toList());
    }

    public List<Vulnerability> getVerifiedByUserInProject(UserProjectRelationshipRequest request) {
        userRepository.findById(request.userId())
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was a VERIFIER (not user vs admin because we are accessing uservuln defined role)
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(request.userId(), RoleInVuln.VERIFIER);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .filter(v -> v.getProject().getId().equals(request.projectId()))  // ‚úÖ filter by project
                .collect(Collectors.toList());
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\uservulnerability\VulnerabilityAssignAction.java:
<code>
package com.brentcodes.springboot.librarysystem.uservulnerability;

import jakarta.validation.constraints.NotNull;

public record VulnerabilityAssignAction(
        @NotNull Long userId,
        @NotNull Long vulnId,
        @NotNull Long projectId,
        @NotNull RoleInVuln role
) {
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\uservulnerability\VulnerabilityRevokeAction.java:
<code>
package com.brentcodes.springboot.librarysystem.uservulnerability;

import jakarta.validation.constraints.NotNull;

public record VulnerabilityRevokeAction(
        @NotNull Long userId,
        @NotNull Long vulnId,
        @NotNull Long projectId
) {}


</code>

src\main\java\com\brentcodes\springboot\librarysystem\uservulnerability\VulnerabilitySelfAssignRevoke.java:
<code>
package com.brentcodes.springboot.librarysystem.uservulnerability;

import jakarta.validation.constraints.NotNull;
import org.springframework.lang.NonNull;

public record VulnerabilitySelfAssignRevoke(
    @NotNull Long vulnId,
    @NotNull Long projectId
){}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\vulnerability\ChangeVulnStatusRequest.java:
<code>
package com.brentcodes.springboot.librarysystem.vulnerability;

import jakarta.validation.constraints.NotNull;

public record ChangeVulnStatusRequest(
        @NotNull Long projectId,
        @NotNull Long vulnId,
        @NotNull VulnStatus newStatus
) {}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\vulnerability\Severity.java:
<code>
package com.brentcodes.springboot.librarysystem.vulnerability;

public enum Severity {
    LOW,
    MEDIUM,
    HIGH,
    CRITICAL
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\vulnerability\Vulnerability.java:
<code>
package com.brentcodes.springboot.librarysystem.vulnerability;

import com.brentcodes.springboot.librarysystem.project.Project;
import com.brentcodes.springboot.librarysystem.uservulnerability.UserVulnerability;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;
import java.util.Objects;
import java.util.Set;
import java.util.HashSet;

@Data
@Entity
@Table(name = "vulnerability")
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonIgnoreProperties({"hibernateLazyInitializer", "handler"})
public class Vulnerability {
    @Id
    @SequenceGenerator(
            name = "vulnerability_sequence",
            sequenceName = "vulnerability_sequence",
            allocationSize = 1
    )
    @GeneratedValue(
            strategy = GenerationType.SEQUENCE,
            generator = "vulnerability_sequence"
    )
    private Long id;

    @Column(nullable=false)
    private String title;
    @Column(length=4000)
    private String description;

    // Security-first fields
    private String cveId;     // e.g., "CVE-2024-12345" (optional)
    private String cweId;     // e.g., "CWE-79" (optional)

    @Enumerated(EnumType.STRING)
    private Severity severity;

    @Enumerated(EnumType.STRING)
    private VulnStatus status;

    private Instant updatedAt;
    private Instant reportedAt;
    private Instant dueAt;
    private Instant patchedAt;
    private Instant verifiedAt;

    private String repository; // what repo the bug was found in
    private String commitHash; // what git command or etc. caused it

    // üîë Project ‚Üî Vulnerability (many vulnerabilities to one project)
    @ManyToOne(fetch = FetchType.LAZY) // cascade
    @JoinColumn(name = "project_id", nullable = false)
    @JsonIgnore
    private Project project;

    // "Hey, I‚Äôm Vulnerability.java, and I know I‚Äôm related to many UserVulnerbility entries via the vulnerability field in that class."
    // üîë Relationships
    @OneToMany(mappedBy = "vulnerability", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<UserVulnerability> userVulnerabilities = new HashSet<>();


    // ‚úÖ Used for backend seeding (e.g., in DataInitializer), avoids @Id injection
    // ‚ö†Ô∏è Excludes auto-generated `id`
    // ‚ÑπÔ∏è Holds similar value to Lombok builder but excludes id
    public Vulnerability(String title, String description, String cveId, String cweId, Severity severity,
                         VulnStatus status, Instant updatedAt, Instant reportedAt, Instant dueAt, Instant patchedAt,
                         Instant verifiedAt,
                         String repository, String commitHash, Project project) {
        this.title = title;
        this.description = description; // The rest are in updateVulnerabilityInfo
        this.cveId = cveId;
        this.cweId = cweId;
        this.severity = severity;
        this.status = status; // ‚Üí `transitionStatus(...)` for updates and already included in report
        this.updatedAt = updatedAt; // No custom method: set inside all update methods
        this.reportedAt = reportedAt; // No custom method: set at creation only
        this.dueAt = dueAt;
        this.patchedAt = patchedAt; // ‚Üí `completeAssignment(...)` (ASSIGNEE)
        this.verifiedAt = verifiedAt; // ‚Üí `completeAssignment(...)` (VERIFIER)
        this.repository = repository;
        this.commitHash = commitHash;
        this.project = project;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Vulnerability)) return false;
        Vulnerability other = (Vulnerability) o;
        return id != null && id.equals(other.id);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(id);
    }
}


</code>

src\main\java\com\brentcodes\springboot\librarysystem\vulnerability\VulnerabilityController.java:
<code>
package com.brentcodes.springboot.librarysystem.vulnerability;

import com.brentcodes.springboot.librarysystem.backendconfig.ApiResponse;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

// Don't include role names in endpoints
@PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
@RestController
@RequestMapping(path = "api/v1/vulnerabilities")
// Each of the methods for vulnerability require a projectId since they are each linked to a project
public class VulnerabilityController {
    private final VulnerabilityService vulnerabilityService;

    // @Autowired, dont need this for single constructors
    public VulnerabilityController(VulnerabilityService vulnerabilityService) {
        this.vulnerabilityService = vulnerabilityService;
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    // Report a vulnerability (whether in dashboard or within the project tab). EACH VULN NEEDS TO HAVE A PROJECT AND A USER
    @PostMapping("/report/{projectId}")
    public ResponseEntity<ApiResponse> reportProjectVulnerability(
            @PathVariable Long projectId,
            @Valid @RequestBody VulnerabilityReportRequest request,
            Authentication authentication
    ) {
        vulnerabilityService.reportProjectVulnerability(projectId, request, authentication);
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerability reported successfully"));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    // Update previously reported vulnerability DESCRIPTION; Returns confirmation message
    // Everyone should be able to do this since it does not transition VULN STATUS
    @PostMapping("/update/{projectId}/{vulnerabilityId}") // we could have {} id field but we input it in the request body instead
    public ResponseEntity<ApiResponse> updateProjectVulnerabilityDescription(@PathVariable Long projectId, @PathVariable Long vulnerabilityId, @RequestBody VulnerabilityUpdateRequest request, Authentication authentication) {
        vulnerabilityService.updateProjectVulnerabilityDescription(projectId, vulnerabilityId, request, authentication);
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerability updated successfully"));
    }

    @PreAuthorize("@projectSecurity.hasProjectRole(authentication, #projectId, 'LEAD')")
    @DeleteMapping("/delete/{projectId}/{vulnerabilityId}")
    public ResponseEntity<ApiResponse> deleteProjectVulnerability(
            @PathVariable Long projectId,
            @PathVariable Long vulnerabilityId
    ) {
        vulnerabilityService.deleteProjectVulnerability(projectId, vulnerabilityId);
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerability deleted successfully"));
    }


    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #request.projectId())")
    @PostMapping("/transition")
    public ResponseEntity<ApiResponse> transitionProjectVulnerabilityStatus(
            @RequestBody ChangeVulnStatusRequest request,
            Authentication authentication
    ) {
        vulnerabilityService.transitionProjectVulnerabilityStatus(request, authentication);
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerability status updated"));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    /// Getting project vulnerabilities and other stuff ===============================
    // View all project vulnerabilities (whether resolved or not); Returns List<Vulnerability> (check status for service)
    @GetMapping(path = "/all/{projectId}")
    public ResponseEntity<ApiResponse> getProjectVulnerabilities(@PathVariable Long projectId) {
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities retrieved successfully", vulnerabilityService.getProjectVulnerabilities(projectId)));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    // Get project vulnerabilities by id
    @GetMapping("/{projectId}/{vulnerabilityId}")
    public ResponseEntity<ApiResponse> getProjectVulnerabilityById(@PathVariable Long projectId, @PathVariable Long vulnerabilityId) {
        Vulnerability vuln = vulnerabilityService.getProjectVulnerabilityById(projectId, vulnerabilityId);
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerability retrieved", vuln));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    // Search by title
    @GetMapping("/title/{projectId}/{title}")
    public ResponseEntity<ApiResponse> getProjectVulnerabilityByTitle(@PathVariable Long projectId, @PathVariable String title) {
        Vulnerability vuln = vulnerabilityService.getProjectVulnerabilityByTitle(projectId, title);
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerability found", vuln));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    // Filter by severity
    @GetMapping("/severity/{projectId}/{severity}")
    public ResponseEntity<ApiResponse> getProjectVulnerabilitiesBySeverity(@PathVariable Long projectId, @PathVariable Severity severity) {
        return ResponseEntity.ok(new ApiResponse(true, "Filtered by severity", vulnerabilityService.getProjectVulnerabilitiesBySeverity(projectId, severity)));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    // Get overdue vulnerabilities
    @GetMapping("/overdue/{projectId}")
    public ResponseEntity<ApiResponse> getOverdueProjectVulnerabilities(@PathVariable Long projectId) {
        return ResponseEntity.ok(new ApiResponse(true, "Overdue vulnerabilities", vulnerabilityService.getOverdueProjectVulnerabilities(projectId)));
    }

    // // I can also create a sort method that filters by created or pasted from the back-end into the front end (sort order)
    //    // This would return an ordered list that would be pasted in the front end
    //    // getMyProjectsSortedBySeverity or most recently added
    //    // getMyProjectsSortedByProgress (or filter them by severity/progress)
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\vulnerability\VulnerabilityReportRequest.java:
<code>
package com.brentcodes.springboot.librarysystem.vulnerability;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import org.springframework.lang.NonNull;

import java.time.Instant;

public record VulnerabilityReportRequest(
        @NotBlank String title, // required fields
        String description,
        String cveId,
        String cweId,
        @NotNull Severity severity,
        @NotNull VulnStatus status,
        @NotNull Instant dueAt,
        String repository,
        String commitHash
) {}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\vulnerability\VulnerabilityRepository.java:
<code>
package com.brentcodes.springboot.librarysystem.vulnerability;

import org.springframework.data.jpa.repository.JpaRepository;

import java.time.Instant;
import java.util.List;
import java.util.Optional;

public interface VulnerabilityRepository extends JpaRepository<Vulnerability, Long> {
    //Spring Data JPA, you can write custom SQL-like behavior by just defining method names in your repository
    // interface ‚Äî as long as you follow Spring‚Äôs naming conventions.
    Optional<Vulnerability> findVulnerabilityByProjectIdAndId(Long projectId, Long vulnerabilityId);

    List<Vulnerability> findVulnerabilitiesByProjectId(Long projectId);

    Optional<Vulnerability> findVulnerabilityByProjectIdAndTitle(Long projectId, String title);

    List<Vulnerability> findByDueAtBeforeAndStatusNotAndProjectId(Instant dueAtBefore, VulnStatus status, Long projectId);

    List<Vulnerability> findVulnerabilitiesByProjectIdAndSeverity(Long projectId, Severity severity);

    // Admin Functions ---------------------------------
    Optional<Vulnerability> findVulnerabilityById(Long vulnerabilityId);

    Optional<Vulnerability> findVulnerabilityByTitle(String title);

    List<Vulnerability> findVulnerabilitiesBySeverity(Severity severity);

    List<Vulnerability> findByDueAtBeforeAndStatusNot(Instant now, VulnStatus vulnStatus);

    Vulnerability getVulnerabilitiesById(Long id);
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\vulnerability\VulnerabilityService.java:
<code>
package com.brentcodes.springboot.librarysystem.vulnerability;

import com.brentcodes.springboot.librarysystem.project.Project;
import com.brentcodes.springboot.librarysystem.project.ProjectRepository;
import com.brentcodes.springboot.librarysystem.user.User;
import com.brentcodes.springboot.librarysystem.user.UserPrincipal;
import com.brentcodes.springboot.librarysystem.user.UserRepository;
import com.brentcodes.springboot.librarysystem.userproject.ProjectRole;
import com.brentcodes.springboot.librarysystem.userproject.UserProject;
import com.brentcodes.springboot.librarysystem.userproject.UserProjectId;
import com.brentcodes.springboot.librarysystem.userproject.UserProjectRepository;
import com.brentcodes.springboot.librarysystem.uservulnerability.*;
import jakarta.persistence.EntityNotFoundException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.RequestBody;

import java.time.Instant;
import java.util.List;

// Responsible for vulnerability logic (not anything to do with students)
@Service
public class VulnerabilityService {
    private final VulnerabilityRepository vulnerabilityRepository;
    private final ProjectRepository projectRepository;
    private final UserProjectRepository userProjectRepository;
    private final UserRepository userRepository;
    private final UserVulnerabilityRepository userVulnerabilityRepository;

    @Autowired
    public VulnerabilityService(VulnerabilityRepository vulnerabilityRepository, ProjectRepository projectRepository, UserProjectRepository userProjectRepository, UserRepository userRepository,  UserVulnerabilityRepository userVulnerabilityRepository) {
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.projectRepository = projectRepository;
        this.userProjectRepository = userProjectRepository;
        this.userRepository = userRepository;
        this.userVulnerabilityRepository = userVulnerabilityRepository;
    }

    @Transactional // if anything fails, roll back all changes
    public void reportProjectVulnerability(Long projectId, VulnerabilityReportRequest request, Authentication authentication) {
        // Validate input fields before proceeding (not needed cuz we have notBlank and nonnull tags

        // Get the authenticated user's ID
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        // Fetch user from DB
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with ID: " + userId));

        // Get the project by id
        Project project = projectRepository.findById(projectId)
                .orElseThrow(() -> new EntityNotFoundException("Project not found"));

        // ‚úÖ Check membership (user must be in the project)
        UserProjectId membershipId = new UserProjectId(userId, projectId);
        if (!userProjectRepository.existsById(membershipId)) {
            throw new AccessDeniedException("You are not a member of this project");
        }

        // ‚úÖ 1. Create the Vulnerability tied to Project
        Vulnerability vuln = Vulnerability.builder()
                .title(request.title())
                // will be null if doesn't exist which is fine (only if we use the null object do we get null pointer)
                .description(request.description())
                .cveId(request.cveId())
                .cweId(request.cweId())
                .severity(request.severity())
                .status(request.status())             // ‚úÖ user-provided
                .updatedAt(null) // no updates yet
                .reportedAt(Instant.now())            // üîê system-generated
                .dueAt(request.dueAt())
                .repository(request.repository())
                .commitHash(request.commitHash())
                .project(project)   // üîë foreign key (project_id)
                .build();

        Vulnerability saved = vulnerabilityRepository.save(vuln);

        // ‚úÖ 2. Create the User ‚Üî Vulnerability link
        UserVulnerability link = UserVulnerability.builder()
                .id(new UserVulnerabilityId(user.getId(), saved.getId()))
                .user(user)
                .vulnerability(saved)
                .role(RoleInVuln.REPORTER)
                .selfAssigned(false) // optional but good for clarity
                .assignedAt(Instant.now()) // optional audit info
                .build();
        userVulnerabilityRepository.save(link);

        // Project Vuln link already exists because each vulnerability has a project
    }

    // Could technically be in VulnService but I think of it as uservuln
    @Transactional // if anything fails, roll back all changes
    public void updateProjectVulnerabilityDescription(Long projectId, Long vulnerabilityId, VulnerabilityUpdateRequest request, Authentication authentication) {
        // Validate input fields before proceeding (not needed cuz we have notBlank and nonnull tags

        // 1. Get the authenticated user's ID (Runs JWT authentication filter)
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        // 2. Check user exists
        userRepository.findById(userId).orElseThrow(() -> new UsernameNotFoundException("User not found with ID: " + userId));

        // ‚úÖ Check membership (user must be in the project)
        UserProjectId membershipId = new UserProjectId(userId, projectId);
        if (!userProjectRepository.existsById(membershipId)) {
            throw new AccessDeniedException("You are not a member of this project");
        }

        // 3. Get the vulnerability (while also checking it is in the project) to update
        Vulnerability vuln = vulnerabilityRepository.findVulnerabilityByProjectIdAndId(projectId, vulnerabilityId)
                .orElseThrow(() -> new EntityNotFoundException("Vulnerability not found with ID: " + vulnerabilityId));


//        // ‚úÖ 4. Check that this user is REPORTER (check a relationship exists)
//        boolean isReporter = userVulnerabilityRepository.existsByUserIdAndVulnerabilityIdAndRole(userId, vulnerabilityId, RoleInVuln.REPORTER);

        // 4. Update mutable fields (backend controls `reportedAt`)... can be null
        if (request.title() != null && !request.title().isBlank()) {
            vuln.setTitle(request.title());
        }

        if (request.description() != null) {
            vuln.setDescription(request.description());
        }

        if (request.cveId() != null) {
            vuln.setCveId(request.cveId());
        }

        if (request.cweId() != null) {
            vuln.setCweId(request.cweId());
        }

        if (request.severity() != null) {
            vuln.setSeverity(request.severity());
        }

        if (request.dueAt() != null) {
            vuln.setDueAt(request.dueAt());
        }

        if (request.repository() != null) {
            vuln.setRepository(request.repository());
        }

        if (request.commitHash() != null) {
            vuln.setCommitHash(request.commitHash());
        }

        vulnerabilityRepository.save(vuln); // automatically updates the pointers within uservuln objects
    }

    @Transactional
    public void deleteProjectVulnerability(Long projectId, Long vulnerabilityId) {
        Vulnerability vuln = vulnerabilityRepository.findById(vulnerabilityId)
                .orElseThrow(() -> new EntityNotFoundException("Vulnerability not found"));

        if (!vuln.getProject().getId().equals(projectId)) {
            throw new IllegalArgumentException("Vulnerability does not belong to this project");
        }

        vulnerabilityRepository.delete(vuln);
    }

    @Transactional // if anything fails, roll back all changes
    public void transitionProjectVulnerabilityStatus(ChangeVulnStatusRequest request, Authentication authentication) {
        // Validate input fields before proceeding (not needed cuz we have notBlank and nonnull tags

        // Get the authenticated user's ID (Runs JWT authentication filter)
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        Vulnerability vuln = vulnerabilityRepository.findById(request.vulnId())
                .orElseThrow(() -> new EntityNotFoundException("Vulnerability not found"));

        // Check user exists
        userRepository.findById(userId).orElseThrow(() -> new UsernameNotFoundException("User not found with ID: " + userId));

        // Check project role
        ProjectRole projectRole = userProjectRepository.findByUserIdAndProjectId(userId, request.projectId())
                .map(UserProject::getRole)
                .orElseThrow(() -> new AccessDeniedException("User not in this project"));

        // Check role in vulnerability (if exists)
        RoleInVuln roleInVuln = userVulnerabilityRepository.findByUserIdAndVulnerabilityId(userId, vuln.getId())
                .map(UserVulnerability::getRole)
                .orElse(null); // null if they're lead but not assigned directly

        // Validate transition based on roles
        VulnStatus current = vuln.getStatus();
        VulnStatus target = request.newStatus();

        if (!isTransitionAllowed(projectRole, roleInVuln, current, target)) {
            throw new AccessDeniedException(
                    String.format("You cannot transition from %s to %s with your role", current, target)
            );
        }

        // 4. Apply the transition
        vuln.setStatus(target);
        vuln.setUpdatedAt(Instant.now());
        vulnerabilityRepository.save(vuln);
    }

    ///  Getting project vulnerabilities etc. (more like ProjectVuln Stuff but in VulnController)
    @Transactional(readOnly = true) // Optional tag for read only stuff (basically all the methods in this class)
    public List<Vulnerability> getProjectVulnerabilities(Long projectId) {
        // Lists cannot be optional so lambda statements that make easy conversion are kinda useless
        List<Vulnerability> vulnerabilities = vulnerabilityRepository.findVulnerabilitiesByProjectId(projectId);

        // I need to use is empty for lists
        if (vulnerabilities.isEmpty()) {
            throw new EntityNotFoundException("No vulnerabilities found");
        }

        return vulnerabilities;
    }

    public Vulnerability getProjectVulnerabilityById(Long projectId, Long vulnerabilityId) {
        return vulnerabilityRepository.findVulnerabilityByProjectIdAndId(projectId, vulnerabilityId)
                .orElseThrow(() -> new EntityNotFoundException("Vulnerability with id '" + vulnerabilityId + "' not found"));
    }

    public Vulnerability getProjectVulnerabilityByTitle(Long projectId, String title) {
        // use lambda statements for single object entities (not lists)
        return vulnerabilityRepository.findVulnerabilityByProjectIdAndTitle(projectId, title)
                .orElseThrow(() -> new EntityNotFoundException("Vulnerability with title '" + title + "' not found"));
        // basically doing this, converting optional into a regular type
//        Optional<Vulnerability> optionalVulnerability = vulnerabilityRepository.findByTitle(title);
//
//        if (optionalVulnerability.isPresent()) {
//            return optionalVulnerability.get(); // turns it back into a vulnerability object
//        } else {
//            // handle not found case however you want
//            throw new IllegalStateException("Vulnerability with title '" + title + "' not found");
//        }
    }

    public List<Vulnerability> getProjectVulnerabilitiesBySeverity(Long projectId, Severity severity) {
        List<Vulnerability> vulnerabilities = vulnerabilityRepository.findVulnerabilitiesByProjectIdAndSeverity(projectId, severity);

        if (vulnerabilities.isEmpty()) {
            throw new EntityNotFoundException("Vulnerabilities with severity of " + severity + " not found");
        }
        return vulnerabilities;
    }

    public List<Vulnerability> getOverdueProjectVulnerabilities(Long projectId) {
        List<Vulnerability> vulnerabilities = vulnerabilityRepository.findByDueAtBeforeAndStatusNotAndProjectId(Instant.now(), VulnStatus.VERIFIED, projectId);

        if (vulnerabilities.isEmpty()) {
            throw new EntityNotFoundException("No overdue vulnerabilities found");
        }
        return vulnerabilities;
    }


    private boolean isTransitionAllowed(ProjectRole projectRole, RoleInVuln roleInVuln,
                                        VulnStatus current, VulnStatus target) {

        // LEAD can always transition
        if (projectRole == ProjectRole.LEAD) return true;

        // PROGRAMMER rules
        if (projectRole == ProjectRole.PROGRAMMER) {
            if (roleInVuln != RoleInVuln.ASSIGNEE) {
                return false; // Must be ASSIGNEE to transition
            }
            return (current == VulnStatus.REPORTED && target == VulnStatus.IN_PROGRESS) ||
                    (current == VulnStatus.IN_PROGRESS && target == VulnStatus.PATCHED);
        }

        // TESTER rules
        if (projectRole == ProjectRole.TESTER) {
            if (roleInVuln != RoleInVuln.VERIFIER) {
                return false; // Must be VERIFIER to transition
            }
            return (current == VulnStatus.PATCHED && target == VulnStatus.UNDER_REVIEW) ||
                    (current == VulnStatus.UNDER_REVIEW && target == VulnStatus.VERIFIED);
        }

        // Default deny
        return false;
    }
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\vulnerability\VulnerabilityUpdateRequest.java:
<code>
package com.brentcodes.springboot.librarysystem.vulnerability;

import java.time.Instant;

public record VulnerabilityUpdateRequest(
        String title,
        String description,
        String cveId,
        String cweId,
        Severity severity,
        Instant dueAt,
        String repository,
        String commitHash
) {}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\vulnerability\VulnStatus.java:
<code>
package com.brentcodes.springboot.librarysystem.vulnerability;

public enum VulnStatus {
    REPORTED,
    IN_PROGRESS,
    PATCHED,
    UNDER_REVIEW,
    VERIFIED
}

</code>

src\main\java\com\brentcodes\springboot\librarysystem\webconfig\WebConfig.java:
<code>
package com.brentcodes.springboot.librarysystem.webconfig;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("http://localhost:3000") // üî• Exact origin (not "*")
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true); // ‚úÖ Required for cookies like JSESSIONID
    }
}

</code>

src\main\resources\application.properties:
<code>
spring.application.name=springboot

# force restart removes all catched data; this is essential when the database names are changed
spring.datasource.url=jdbc:postgresql://localhost:5432/clamped
spring.datasource.username=postgres
spring.datasource.password=851686
spring.datasource.driver-class-name=org.postgresql.Driver
# update will leave the code and database data (post and puts) untouched
# create-drop will restart all the schemas and databases (deletes them when app is not running)

# ========== Hibernate/JPA Management ==========
spring.jpa.show-sql=true
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.transaction.jta.platform=true

spring.jpa.hibernate.ddl-auto=create-drop
server.error.include-message=always


# ========== Session Management ==========
spring.session.store-type=jdbc
# Auto-create SPRING_SESSION tables (once)
# spring.sql.init.schema-locations=classpath:spring-session-schema.sql
# change to 'never' in prod after table is created
spring.session.jdbc.initialize-schema=always

# Optional: session timeout (DB session lifetime)
server.servlet.session.timeout=7d

# Optional: secure cookie settings
server.servlet.session.cookie.http-only=false
# False for dev stage
server.servlet.session.cookie.name=JSESSIONID

# Remove SameSite=None and keep secure=false for local dev
server.servlet.session.cookie.secure=false
# server.servlet.session.cookie.same-site=None  # Comment this out
server.servlet.session.cookie.same-site=Lax

# Run cleanup for expired sessions (which die after 7 days) every 5 minutes instead of 1 minute (optional)
spring.session.jdbc.cleanup-cron=0 */5 * * * *

# Cookie survives reloads for 7 days (JSESSION ID LIFETIME)
server.servlet.session.cookie.max-age=7d
# Link to postgres (we dont want this shit cuz we havnt generated anything from postgres)
# spring.session.jdbc.platform=postgres


# Debug logging for session initialization
# logging.level.org.springframework.session=DEBUG
# logging.level.org.springframework.jdbc.datasource.init=DEBUG
# logging.level.org.springframework.boot.autoconfigure.session=DEBUG
# logging.level.org.springframework.session.jdbc=DEBUG
# logging.level.org.springframework.session.jdbc.config.annotation.web.http=DEBUG
logging.level.org.springframework.security=DEBUG
logging.level.com.brentcodes=DEBUG
# Shows Spring JDBC queries like session cleanup
logging.level.org.springframework.jdbc.core.JdbcTemplate=DEBUG



# Also enable SQL logging to see if table creation is attempted
# logging.level.org.springframework.jdbc=DEBUG

</code>

src\test\java\com\brentcodes\springboot\SpringbootApplicationTests.java:
<code>
package com.brentcodes.springboot;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class SpringbootApplicationTests {

	@Test
	void contextLoads() {
	}

}

</code>


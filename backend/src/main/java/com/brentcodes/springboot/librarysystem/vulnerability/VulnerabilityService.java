package com.brentcodes.springboot.librarysystem.vulnerability;

import com.brentcodes.springboot.librarysystem.notification.NotificationService;
import com.brentcodes.springboot.librarysystem.notification.NotificationType;
import com.brentcodes.springboot.librarysystem.project.Project;
import com.brentcodes.springboot.librarysystem.project.ProjectRepository;
import com.brentcodes.springboot.librarysystem.user.User;
import com.brentcodes.springboot.librarysystem.user.UserPrincipal;
import com.brentcodes.springboot.librarysystem.user.UserRepository;
import com.brentcodes.springboot.librarysystem.userproject.ProjectRole;
import com.brentcodes.springboot.librarysystem.userproject.UserProject;
import com.brentcodes.springboot.librarysystem.userproject.UserProjectId;
import com.brentcodes.springboot.librarysystem.userproject.UserProjectRepository;
import com.brentcodes.springboot.librarysystem.uservulnerability.*;
import jakarta.persistence.EntityNotFoundException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.RequestBody;

import java.time.Instant;
import java.util.List;

// Responsible for vulnerability logic (not anything to do with students)
@Service
public class VulnerabilityService {
    private final VulnerabilityRepository vulnerabilityRepository;
    private final ProjectRepository projectRepository;
    private final UserProjectRepository userProjectRepository;
    private final UserRepository userRepository;
    private final UserVulnerabilityRepository userVulnerabilityRepository;
    private final NotificationService notificationService;

    @Autowired
    public VulnerabilityService(VulnerabilityRepository vulnerabilityRepository, ProjectRepository projectRepository, UserProjectRepository userProjectRepository, UserRepository userRepository, UserVulnerabilityRepository userVulnerabilityRepository, NotificationService notificationService) {
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.projectRepository = projectRepository;
        this.userProjectRepository = userProjectRepository;
        this.userRepository = userRepository;
        this.userVulnerabilityRepository = userVulnerabilityRepository;
        this.notificationService = notificationService;
    }

    @Transactional // if anything fails, roll back all changes
    public void reportProjectVulnerability(Long projectId, VulnerabilityReportRequest request, Authentication authentication) {
        // Validate input fields before proceeding (not needed cuz we have notBlank and nonnull tags

        // Get the authenticated user's ID
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        // Fetch user from DB
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with ID: " + userId));

        // Get the project by id
        Project project = projectRepository.findById(projectId)
                .orElseThrow(() -> new EntityNotFoundException("Project not found"));

        // ‚úÖ Check membership (user must be in the project)
        UserProjectId membershipId = new UserProjectId(userId, projectId);
        if (!userProjectRepository.existsById(membershipId)) {
            throw new AccessDeniedException("You are not a member of this project");
        }

        // ‚úÖ 1. Create the Vulnerability tied to Project
        Vulnerability vuln = Vulnerability.builder()
                .title(request.title())
                // will be null if doesn't exist which is fine (only if we use the null object do we get null pointer)
                .description(request.description())
                .cveId(request.cveId())
                .cweId(request.cweId())
                .severity(request.severity())
                .status(request.status())             // ‚úÖ user-provided
                .updatedAt(null) // no updates yet
                .reportedAt(Instant.now())            // üîê system-generated
                .dueAt(request.dueAt())
                .repository(request.repository())
                .commitHash(request.commitHash())
                .codeSnippet(request.codeSnippet())
                .codeLanguage(request.codeLanguage())
                .project(project)   // üîë foreign key (project_id)
                .build();

        Vulnerability saved = vulnerabilityRepository.save(vuln);

        // ‚úÖ 2. Create the User ‚Üî Vulnerability link
        UserVulnerability link = UserVulnerability.builder()
                .id(new UserVulnerabilityId(user.getId(), saved.getId()))
                .user(user)
                .vulnerability(saved)
                .role(RoleInVuln.REPORTER)
                .selfAssigned(false) // optional but good for clarity
                .assignedAt(Instant.now()) // optional audit info
                .build();
        userVulnerabilityRepository.save(link);

        // Notify all project members except the reporter
        List<Long> memberIds = userProjectRepository.findAllByProjectId(projectId).stream()
                .map(up -> up.getUser().getId())
                .filter(id -> !id.equals(userId))
                .toList();
        notificationService.notifyAll(
                memberIds, NotificationType.VULN_REPORTED,
                user.getFirstname() + " " + user.getLastname() + " reported a new vulnerability: '" + saved.getTitle() + "'",
                projectId, saved.getId()
        );

        // Project Vuln link already exists because each vulnerability has a project
    }

    // Could technically be in VulnService but I think of it as uservuln
    @Transactional // if anything fails, roll back all changes
    public void updateProjectVulnerabilityDescription(Long projectId, Long vulnerabilityId, VulnerabilityUpdateRequest request, Authentication authentication) {
        // Validate input fields before proceeding (not needed cuz we have notBlank and nonnull tags

        // 1. Get the authenticated user's ID (Runs JWT authentication filter)
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        // 2. Check user exists
        userRepository.findById(userId).orElseThrow(() -> new UsernameNotFoundException("User not found with ID: " + userId));

        // ‚úÖ Check membership (user must be in the project)
        UserProjectId membershipId = new UserProjectId(userId, projectId);
        if (!userProjectRepository.existsById(membershipId)) {
            throw new AccessDeniedException("You are not a member of this project");
        }

        // 3. Get the vulnerability (while also checking it is in the project) to update
        Vulnerability vuln = vulnerabilityRepository.findVulnerabilityByProjectIdAndId(projectId, vulnerabilityId)
                .orElseThrow(() -> new EntityNotFoundException("Vulnerability not found with ID: " + vulnerabilityId));


        // 4. Update mutable fields (backend controls `reportedAt`)... can be null
        if (request.title() != null && !request.title().isBlank()) {
            vuln.setTitle(request.title());
        }

        if (request.description() != null) {
            vuln.setDescription(request.description());
        }

        if (request.cveId() != null) {
            vuln.setCveId(request.cveId());
        }

        if (request.cweId() != null) {
            vuln.setCweId(request.cweId());
        }

        if (request.severity() != null) {
            vuln.setSeverity(request.severity());
        }

        if (request.dueAt() != null) {
            vuln.setDueAt(request.dueAt());
        }

        if (request.repository() != null) {
            vuln.setRepository(request.repository());
        }

        if (request.commitHash() != null) {
            vuln.setCommitHash(request.commitHash());
        }

        if (request.codeSnippet() != null) {
            vuln.setCodeSnippet(request.codeSnippet());
        }

        if (request.codeLanguage() != null) {
            vuln.setCodeLanguage(request.codeLanguage());
        }

        vulnerabilityRepository.save(vuln); // automatically updates the pointers within uservuln objects
    }

    @Transactional
    public void deleteProjectVulnerability(Long projectId, Long vulnerabilityId) {
        Vulnerability vuln = vulnerabilityRepository.findById(vulnerabilityId)
                .orElseThrow(() -> new EntityNotFoundException("Vulnerability not found"));

        if (!vuln.getProject().getId().equals(projectId)) {
            throw new IllegalArgumentException("Vulnerability does not belong to this project");
        }

        vulnerabilityRepository.delete(vuln);
    }

    @Transactional // if anything fails, roll back all changes
    public void transitionProjectVulnerabilityStatus(ChangeVulnStatusRequest request, Authentication authentication) {
        // Validate input fields before proceeding (not needed cuz we have notBlank and nonnull tags

        // Get the authenticated user's ID (Runs JWT authentication filter)
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        Vulnerability vuln = vulnerabilityRepository.findById(request.vulnId())
                .orElseThrow(() -> new EntityNotFoundException("Vulnerability not found"));

        // Check user exists
        userRepository.findById(userId).orElseThrow(() -> new UsernameNotFoundException("User not found with ID: " + userId));

        // Check project role
        ProjectRole projectRole = userProjectRepository.findByUserIdAndProjectId(userId, request.projectId())
                .map(UserProject::getRole)
                .orElseThrow(() -> new AccessDeniedException("User not in this project"));

        // Check role in vulnerability (if exists)
        RoleInVuln roleInVuln = userVulnerabilityRepository.findByUserIdAndVulnerabilityId(userId, vuln.getId())
                .map(UserVulnerability::getRole)
                .orElse(null); // null if they're lead but not assigned directly

        // Validate transition based on roles
        VulnStatus current = vuln.getStatus();
        VulnStatus target = request.newStatus();

        if (!isTransitionAllowed(projectRole, roleInVuln, current, target)) {
            throw new AccessDeniedException(
                    String.format("You cannot transition from %s to %s with your role", current, target)
            );
        }

        // 4. Apply the transition
        vuln.setStatus(target);
        vuln.setUpdatedAt(Instant.now());
        vulnerabilityRepository.save(vuln);
    }

    ///  Getting project vulnerabilities etc. (more like ProjectVuln Stuff but in VulnController)
    @Transactional(readOnly = true) // Optional tag for read only stuff (basically all the methods in this class)
    public List<Vulnerability> getProjectVulnerabilities(Long projectId) {
        // Lists cannot be optional so lambda statements that make easy conversion are kinda useless
        List<Vulnerability> vulnerabilities = vulnerabilityRepository.findVulnerabilitiesByProjectId(projectId);

        // I need to use is empty for lists
        if (vulnerabilities.isEmpty()) {
            throw new EntityNotFoundException("No vulnerabilities found");
        }

        return vulnerabilities;
    }

    public Vulnerability getProjectVulnerabilityById(Long projectId, Long vulnerabilityId) {
        return vulnerabilityRepository.findVulnerabilityByProjectIdAndId(projectId, vulnerabilityId)
                .orElseThrow(() -> new EntityNotFoundException("Vulnerability with id '" + vulnerabilityId + "' not found"));
    }

    public Vulnerability getProjectVulnerabilityByTitle(Long projectId, String title) {
        // use lambda statements for single object entities (not lists)
        return vulnerabilityRepository.findVulnerabilityByProjectIdAndTitle(projectId, title)
                .orElseThrow(() -> new EntityNotFoundException("Vulnerability with title '" + title + "' not found"));
        // basically doing this, converting optional into a regular type
//        Optional<Vulnerability> optionalVulnerability = vulnerabilityRepository.findByTitle(title);
//
//        if (optionalVulnerability.isPresent()) {
//            return optionalVulnerability.get(); // turns it back into a vulnerability object
//        } else {
//            // handle not found case however you want
//            throw new IllegalStateException("Vulnerability with title '" + title + "' not found");
//        }
    }

    public List<Vulnerability> getProjectVulnerabilitiesBySeverity(Long projectId, Severity severity) {
        List<Vulnerability> vulnerabilities = vulnerabilityRepository.findVulnerabilitiesByProjectIdAndSeverity(projectId, severity);

        if (vulnerabilities.isEmpty()) {
            throw new EntityNotFoundException("Vulnerabilities with severity of " + severity + " not found");
        }
        return vulnerabilities;
    }

    public List<Vulnerability> getOverdueProjectVulnerabilities(Long projectId) {
        List<Vulnerability> vulnerabilities = vulnerabilityRepository.findByDueAtBeforeAndStatusNotAndProjectId(Instant.now(), VulnStatus.VERIFIED, projectId);

        if (vulnerabilities.isEmpty()) {
            throw new EntityNotFoundException("No overdue vulnerabilities found");
        }
        return vulnerabilities;
    }


    private boolean isTransitionAllowed(ProjectRole projectRole, RoleInVuln roleInVuln,
                                        VulnStatus current, VulnStatus target) {

        // LEAD can always transition
        if (projectRole == ProjectRole.LEAD) return true;

        // PROGRAMMER rules
        if (projectRole == ProjectRole.PROGRAMMER) {
            if (roleInVuln != RoleInVuln.ASSIGNEE) {
                return false; // Must be ASSIGNEE to transition
            }
            return (current == VulnStatus.REPORTED && target == VulnStatus.IN_PROGRESS) ||
                    (current == VulnStatus.IN_PROGRESS && target == VulnStatus.PATCHED);
        }

        // TESTER rules
        if (projectRole == ProjectRole.TESTER) {
            if (roleInVuln != RoleInVuln.VERIFIER) {
                return false; // Must be VERIFIER to transition
            }
            return (current == VulnStatus.PATCHED && target == VulnStatus.UNDER_REVIEW) ||
                    (current == VulnStatus.UNDER_REVIEW && target == VulnStatus.VERIFIED);
        }

        // Default deny
        return false;
    }
}

package com.brentcodes.springboot.librarysystem.uservulnerability;

import com.brentcodes.springboot.librarysystem.backendconfig.ApiResponse;
import com.brentcodes.springboot.librarysystem.backendconfig.GlobalExceptionHandler;
import com.brentcodes.springboot.librarysystem.user.User;
import com.brentcodes.springboot.librarysystem.vulnerability.Vulnerability;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/uservulns")
public class UserVulnerabilityController {

    private final UserVulnerabilityService userVulnerabilityService;

    public UserVulnerabilityController(UserVulnerabilityService userVulnerabilityService, GlobalExceptionHandler globalExceptionHandler) {
        this.userVulnerabilityService = userVulnerabilityService;
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #selfAssign.projectId())")
    // Anyone can access this (we pass project and vuln id's for checks)
    @PostMapping("/self-assign")
    public ResponseEntity<ApiResponse> selfAssignToVulnerability(@RequestBody VulnerabilitySelfAssignRevoke selfAssign, Authentication auth) {
        userVulnerabilityService.selfAssignToVulnerability(selfAssign, auth);
        return ResponseEntity.ok(new ApiResponse(true, "You have assigned yourself to this vulnerability"));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #selfRevoke.projectId())")
    // Anyone can access this. Allows them to self remove from a vulnerability
    @DeleteMapping("/self-revoke")
    public ResponseEntity<ApiResponse> selfRevokeFromVulnerability(@RequestBody VulnerabilitySelfAssignRevoke selfRevoke, Authentication auth) {
        userVulnerabilityService.selfRevokeFromVulnerability(selfRevoke, auth);
        return ResponseEntity.ok(new ApiResponse(true, "You have withdrawn yourself from this vulnerability"));
    }

    // Only for project leads. Allows them to assign a member to a vuln (and gives them the role for that vuln... should also update vuln status)
    @PreAuthorize("@projectSecurity.hasProjectRole(authentication, #vulnerabilityAssignAction.projectId(), 'LEAD')")
    @PostMapping("/assign")
    public ResponseEntity<ApiResponse> assignUserToVulnerability(
            @RequestBody VulnerabilityAssignAction vulnerabilityAssignAction
    ) {
        User user = userVulnerabilityService.assignUserToVulnerability(vulnerabilityAssignAction);
        return ResponseEntity.ok(new ApiResponse(true,
                "User " + user.getFirstname() + " was assigned as " + vulnerabilityAssignAction.role() + " within the project successfully"));
    }

    // Unassign a user from a role (Project Lead) command... maybe update the vuln status?
    @PreAuthorize("@projectSecurity.hasProjectRole(authentication, #vulnerabilityRevokeAction.projectId(), 'LEAD')")
    @DeleteMapping("/unassign")
    public ResponseEntity<ApiResponse> revokeUserFromVulnerability(
            @RequestBody VulnerabilityRevokeAction vulnerabilityRevokeAction
    ) {
        User user = userVulnerabilityService.revokeUserFromVulnerability(vulnerabilityRevokeAction);
        return ResponseEntity.ok(new ApiResponse(true,
                "User " + user.getFirstname() + " was unassigned successfully"));
    }

    /** Global Scoped */
    @GetMapping("/reported")
    public ResponseEntity<ApiResponse> getAllReportedByMe(Authentication authentication) {
        List<VulnerabilityWithProjectDto> reported = userVulnerabilityService.getReportedByMe(authentication);
        if (reported.isEmpty()) {
            return ResponseEntity.ok(new ApiResponse(true, "Wow, such empty üê∂", reported));
        }
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities successfully returned", reported));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    @GetMapping("/reported/{projectId}")
    public ResponseEntity<ApiResponse> getReportedByMeInProject(@PathVariable Long projectId, Authentication authentication) {
        List<Vulnerability> reported = userVulnerabilityService.getReportedByMeInProject(projectId,  authentication);
        if (reported.isEmpty()) {
            return ResponseEntity.ok(new ApiResponse(true, "Wow, such empty üê∂", reported));
        }
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities successfully returned", reported));
    }

    /** Global Scoped */
    @GetMapping("/assigned")
    public ResponseEntity<ApiResponse> getAssignedToMe(Authentication authentication) {
        List<VulnerabilityWithProjectDto> assigned = userVulnerabilityService.getAssignedToMe(authentication);
        if (assigned.isEmpty()) {
            return ResponseEntity.ok(new ApiResponse(true, "Wow, such empty üê∂", assigned));
        }
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities successfully returned", assigned));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    @GetMapping("/assigned/{projectId}")
    public ResponseEntity<ApiResponse> getAssignedToMeInProject(@PathVariable Long projectId, Authentication authentication) {
        List<Vulnerability> assigned = userVulnerabilityService.getAssignedToMeInProject(projectId,  authentication);
        if (assigned.isEmpty()) {
            return ResponseEntity.ok(new ApiResponse(true, "Wow, such empty üê∂", assigned));
        }
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities successfully returned", assigned));
    }

    /** Global Scoped */
    @GetMapping("/verified")
    public ResponseEntity<ApiResponse> getVerifiedByMe(Authentication authentication) {
        List<VulnerabilityWithProjectDto> verified = userVulnerabilityService.getVerifiedByMe(authentication);
        if (verified.isEmpty()) {
            return ResponseEntity.ok(new ApiResponse(true, "Wow, such empty üê∂", verified));
        }
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities successfully returned", verified));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    @GetMapping("/verified/{projectId}")
    public ResponseEntity<ApiResponse> getVerifiedByMeInProject(@PathVariable Long projectId, Authentication authentication) {
        List<Vulnerability> verified = userVulnerabilityService.getVerifiedByMeInProject(projectId,  authentication);
        if (verified.isEmpty()) {
            return ResponseEntity.ok(new ApiResponse(true, "Wow, such empty üê∂", verified));
        }
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities successfully returned", verified));
    }

    // Returns all vulnerabilities in a project with their full assignment lists (who is reporter/assignee/verifier)
    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    @GetMapping("/project-assignments/{projectId}")
    public ResponseEntity<ApiResponse> getProjectAssignments(@PathVariable Long projectId) {
        List<VulnerabilityAssignmentDto> result = userVulnerabilityService.getProjectAssignments(projectId);
        return ResponseEntity.ok(new ApiResponse(true, "Project assignments returned", result));
    }

    // I can also create a sort method that filters by created at in the front end (sort order)
    // This would return an ordered list that would be pasted in the front end
    // getMostRecentlyAssigned to me and more stuff


    // üîê Lead: Find all reports created by a user
    @PreAuthorize("@projectSecurity.hasProjectRole(authentication, #request.projectId(), 'LEAD')")
    @GetMapping("/reported-by-user")
    // ‚ÄúTake the value from the {userId} part of the URL and assign it to this parameter.‚Äù
    public ResponseEntity<ApiResponse> getReportedByUserInProject(@RequestBody UserProjectRelationshipRequest request) {
        List<Vulnerability> reported = userVulnerabilityService.getReportedByUserInProject(request);
        if (reported.isEmpty()) {
            return ResponseEntity.ok(new ApiResponse(true, "Wow, such empty üê∂", reported));
        }
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities successfully returned", reported));
    }

    // üîê Lead: Find all assigned vulns to user
    @PreAuthorize("@projectSecurity.hasProjectRole(authentication, #request.projectId(), 'LEAD')")
    @GetMapping("/assigned-to-user")
    // ‚ÄúTake the value from the {userId} part of the URL and assign it to this parameter.‚Äù
    public ResponseEntity<ApiResponse> getAssignedToUserInProject(@RequestBody UserProjectRelationshipRequest request) {
        List<Vulnerability> assigned = userVulnerabilityService.getAssignedToUserInProject(request);
        if (assigned.isEmpty()) {
            return ResponseEntity.ok(new ApiResponse(true, "Wow, such empty üê∂", assigned));
        }
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities successfully returned", assigned));
    }

    // üîê Lead: Find all vulns verified by a user
    @PreAuthorize("@projectSecurity.hasProjectRole(authentication, #request.projectId(), 'LEAD')")
    @GetMapping("/verified-by-user")
    // ‚ÄúTake the value from the {userId} part of the URL and assign it to this parameter.‚Äù
    public ResponseEntity<ApiResponse> getVerifiedByUserInProject(@RequestBody UserProjectRelationshipRequest request) {
        List<Vulnerability> verified = userVulnerabilityService.getVerifiedByUserInProject(request);
        if (verified.isEmpty()) {
            return ResponseEntity.ok(new ApiResponse(true, "Wow, such empty üê∂", verified));
        }
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities successfully returned", verified));
    }


}


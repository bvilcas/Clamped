package com.brentcodes.springboot.librarysystem.vulnerability;

import com.brentcodes.springboot.librarysystem.backendconfig.ApiResponse;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

// Don't include role names in endpoints
@PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
@RestController
@RequestMapping(path = "api/v1/vulnerabilities")
// Each of the methods for vulnerability require a projectId since they are each linked to a project
public class VulnerabilityController {
    private final VulnerabilityService vulnerabilityService;

    // @Autowired, dont need this for single constructors
    public VulnerabilityController(VulnerabilityService vulnerabilityService) {
        this.vulnerabilityService = vulnerabilityService;
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    // Report a vulnerability (whether in dashboard or within the project tab). EACH VULN NEEDS TO HAVE A PROJECT AND A USER
    @PostMapping("/report/{projectId}")
    public ResponseEntity<ApiResponse> reportProjectVulnerability(
            @PathVariable Long projectId,
            @Valid @RequestBody VulnerabilityReportRequest request,
            Authentication authentication
    ) {
        vulnerabilityService.reportProjectVulnerability(projectId, request, authentication);
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerability reported successfully"));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    // Update previously reported vulnerability DESCRIPTION; Returns confirmation message
    // Everyone should be able to do this since it does not transition VULN STATUS
    @PostMapping("/update/{projectId}/{vulnerabilityId}") // we could have {} id field but we input it in the request body instead
    public ResponseEntity<ApiResponse> updateProjectVulnerabilityDescription(@PathVariable Long projectId, @PathVariable Long vulnerabilityId, @RequestBody VulnerabilityUpdateRequest request, Authentication authentication) {
        vulnerabilityService.updateProjectVulnerabilityDescription(projectId, vulnerabilityId, request, authentication);
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerability updated successfully"));
    }

    @PreAuthorize("@projectSecurity.hasProjectRole(authentication, #projectId, 'LEAD')")
    @DeleteMapping("/delete/{projectId}/{vulnerabilityId}")
    public ResponseEntity<ApiResponse> deleteProjectVulnerability(
            @PathVariable Long projectId,
            @PathVariable Long vulnerabilityId
    ) {
        vulnerabilityService.deleteProjectVulnerability(projectId, vulnerabilityId);
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerability deleted successfully"));
    }


    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #request.projectId())")
    @PostMapping("/transition")
    public ResponseEntity<ApiResponse> transitionProjectVulnerabilityStatus(
            @RequestBody ChangeVulnStatusRequest request,
            Authentication authentication
    ) {
        vulnerabilityService.transitionProjectVulnerabilityStatus(request, authentication);
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerability status updated"));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    /// Getting project vulnerabilities and other stuff ===============================
    // View all project vulnerabilities (whether resolved or not); Returns List<Vulnerability> (check status for service)
    @GetMapping(path = "/all/{projectId}")
    public ResponseEntity<ApiResponse> getProjectVulnerabilities(@PathVariable Long projectId) {
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerabilities retrieved successfully", vulnerabilityService.getProjectVulnerabilities(projectId)));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    // Get project vulnerabilities by id
    @GetMapping("/{projectId}/{vulnerabilityId}")
    public ResponseEntity<ApiResponse> getProjectVulnerabilityById(@PathVariable Long projectId, @PathVariable Long vulnerabilityId) {
        Vulnerability vuln = vulnerabilityService.getProjectVulnerabilityById(projectId, vulnerabilityId);
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerability retrieved", vuln));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    // Search by title
    @GetMapping("/title/{projectId}/{title}")
    public ResponseEntity<ApiResponse> getProjectVulnerabilityByTitle(@PathVariable Long projectId, @PathVariable String title) {
        Vulnerability vuln = vulnerabilityService.getProjectVulnerabilityByTitle(projectId, title);
        return ResponseEntity.ok(new ApiResponse(true, "Vulnerability found", vuln));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    // Filter by severity
    @GetMapping("/severity/{projectId}/{severity}")
    public ResponseEntity<ApiResponse> getProjectVulnerabilitiesBySeverity(@PathVariable Long projectId, @PathVariable Severity severity) {
        return ResponseEntity.ok(new ApiResponse(true, "Filtered by severity", vulnerabilityService.getProjectVulnerabilitiesBySeverity(projectId, severity)));
    }

    @PreAuthorize("@projectSecurity.isProjectMember(authentication, #projectId)")
    // Get overdue vulnerabilities
    @GetMapping("/overdue/{projectId}")
    public ResponseEntity<ApiResponse> getOverdueProjectVulnerabilities(@PathVariable Long projectId) {
        return ResponseEntity.ok(new ApiResponse(true, "Overdue vulnerabilities", vulnerabilityService.getOverdueProjectVulnerabilities(projectId)));
    }

    // // I can also create a sort method that filters by created or pasted from the back-end into the front end (sort order)
    //    // This would return an ordered list that would be pasted in the front end
    //    // getMyProjectsSortedBySeverity or most recently added
    //    // getMyProjectsSortedByProgress (or filter them by severity/progress)
}

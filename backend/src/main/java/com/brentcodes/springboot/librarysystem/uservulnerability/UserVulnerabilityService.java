package com.brentcodes.springboot.librarysystem.uservulnerability;

import com.brentcodes.springboot.librarysystem.notification.NotificationService;
import com.brentcodes.springboot.librarysystem.notification.NotificationType;
import com.brentcodes.springboot.librarysystem.userproject.ProjectRole;
import com.brentcodes.springboot.librarysystem.userproject.ProjectSecurity;
import com.brentcodes.springboot.librarysystem.userproject.UserProject;
import com.brentcodes.springboot.librarysystem.userproject.UserProjectRepository;
import com.brentcodes.springboot.librarysystem.vulnerability.VulnStatus;
import com.brentcodes.springboot.librarysystem.vulnerability.Vulnerability;
import com.brentcodes.springboot.librarysystem.vulnerability.VulnerabilityRepository;
import com.brentcodes.springboot.librarysystem.user.User;
import com.brentcodes.springboot.librarysystem.user.UserPrincipal;
import com.brentcodes.springboot.librarysystem.user.UserRepository;
import jakarta.persistence.EntityNotFoundException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.RequestBody;

import java.time.Instant;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

// Responsible for user and vulnerability logic (anything to do with their relationship) so that includes finding the books of a user
@Service
public class UserVulnerabilityService {

    private final UserVulnerabilityRepository userVulnerabilityRepository;
    private final UserRepository userRepository;
    private final VulnerabilityRepository vulnerabilityRepository;
    private final ProjectSecurity projectSecurity;
    private final UserProjectRepository userProjectRepository;
    private final NotificationService notificationService;

    @Autowired // Not required for single constructors... depends on dependency injection
    public UserVulnerabilityService(UserVulnerabilityRepository userVulnerabilityRepository, UserRepository userRepository, VulnerabilityRepository vulnerabilityRepository,  ProjectSecurity projectSecurity,  UserProjectRepository userProjectRepository, NotificationService notificationService) {
        this.userVulnerabilityRepository = userVulnerabilityRepository;
        this.userRepository = userRepository;
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.projectSecurity = projectSecurity;
        this.userProjectRepository = userProjectRepository;
        this.notificationService = notificationService;
    }

    /** Returns the IDs of all LEAD members of a project (excluding a specific user). */
    private List<Long> getLeadIds(Long projectId, Long excludeUserId) {
        return userProjectRepository.findAllByProjectId(projectId).stream()
                .filter(up -> up.getRole() == ProjectRole.LEAD && !up.getUser().getId().equals(excludeUserId))
                .map(up -> up.getUser().getId())
                .toList();
    }

    @Transactional
    public void selfAssignToVulnerability(VulnerabilitySelfAssignRevoke selfAssign, Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));


        Vulnerability vuln = vulnerabilityRepository.getVulnerabilitiesById(selfAssign.vulnId());

        // Make sure the user is a member of the project
        userProjectRepository.findByUserIdAndProjectId(user.getId(), selfAssign.projectId())
                .map(UserProject::getRole)
                .orElseThrow(() -> new AccessDeniedException("User is not a member of this project"));


        // Prevent Duplicates
        UserVulnerabilityId id = new UserVulnerabilityId(user.getId(), vuln.getId());
        if (userVulnerabilityRepository.existsById(id)) {
            throw new IllegalStateException("You are already assigned to this vulnerability");
        }

        // Determine project role and map to RoleInVuln
        ProjectRole projectRole = projectSecurity.getProjectRole(authentication, vuln.getProject().getId());
        RoleInVuln roleInVuln = switch (projectRole) {
            case PROGRAMMER, LEAD -> RoleInVuln.ASSIGNEE; // Members and leads become assignees
            case TESTER -> RoleInVuln.VERIFIER; // Testers become verifiers
            default -> throw new AccessDeniedException("You are not allowed to self-assign to this vulnerability");
        };

        // Link user and vulnerability with verified role
        UserVulnerability link = UserVulnerability.builder()
                .id(id)
                .user(user)
                .vulnerability(vuln)
                .role(roleInVuln)
                .selfAssigned(true) // optional but good for clarity
                .assignedAt(Instant.now()) // optional audit info
                .build();

        //noinspection DuplicatedCode
        userVulnerabilityRepository.save(link);

        // Update vulnerability status depending on role
        switch (roleInVuln) {
            case ASSIGNEE -> {
                if (vuln.getStatus() == VulnStatus.REPORTED) {
                    vuln.setStatus(VulnStatus.IN_PROGRESS);
                    vuln.setUpdatedAt(Instant.now());
                }
            }
            case VERIFIER -> {
                if (vuln.getStatus() == VulnStatus.PATCHED) {
                    vuln.setStatus(VulnStatus.UNDER_REVIEW);
                    vuln.setUpdatedAt(Instant.now());
                }
            }
        }
        // Save the vuln with updated state
        vulnerabilityRepository.save(vuln);

        notificationService.notifyAll(
                getLeadIds(vuln.getProject().getId(), user.getId()),
                NotificationType.MEMBER_SELF_ASSIGNED,
                user.getFirstname() + " " + user.getLastname() + " self-assigned to '" + vuln.getTitle() + "' as " + roleInVuln.name().toLowerCase(),
                vuln.getProject().getId(), vuln.getId()
        );
    }

    @Transactional
    public void selfRevokeFromVulnerability(VulnerabilitySelfAssignRevoke selfRevoke, Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        Vulnerability vuln = vulnerabilityRepository.getVulnerabilitiesById(selfRevoke.vulnId());

        Long projectId = vuln.getProject().getId();

        // Ensure the user is a member of the project
        userProjectRepository.findByUserIdAndProjectId(user.getId(), projectId)
                .orElseThrow(() -> new AccessDeniedException("User is not a member of this project"));

        // Get the existing UserVulnerability link
        UserVulnerability link = userVulnerabilityRepository
                .findByUserIdAndVulnerabilityId(user.getId(), vuln.getId())
                .orElseThrow(() -> new IllegalStateException("You are not assigned to this vulnerability"));

        RoleInVuln roleInVuln = link.getRole();

        // Delete the link (self unassign)
        userVulnerabilityRepository.delete(link);

        // 5️⃣ Update vulnerability status depending on the role revoked
        switch (roleInVuln) {
            case ASSIGNEE -> {
                boolean hasOtherAssignees = userVulnerabilityRepository
                        .existsByVulnerabilityIdAndRole(selfRevoke.vulnId(), RoleInVuln.ASSIGNEE);
                if (!hasOtherAssignees && vuln.getStatus() == VulnStatus.IN_PROGRESS) {
                    vuln.setStatus(VulnStatus.REPORTED);
                    vuln.setUpdatedAt(Instant.now());
                }
            }
            case VERIFIER -> {
                boolean hasOtherVerifiers = userVulnerabilityRepository
                        .existsByVulnerabilityIdAndRole(selfRevoke.vulnId(), RoleInVuln.VERIFIER);
                if (!hasOtherVerifiers && vuln.getStatus() == VulnStatus.UNDER_REVIEW) {
                    vuln.setStatus(VulnStatus.PATCHED);
                    vuln.setUpdatedAt(Instant.now());
                }
            }
        }

        // Save the vuln with updated state
        vulnerabilityRepository.save(vuln);

        notificationService.notifyAll(
                getLeadIds(vuln.getProject().getId(), user.getId()),
                NotificationType.MEMBER_SELF_REVOKED,
                user.getFirstname() + " " + user.getLastname() + " unassigned themselves from '" + vuln.getTitle() + "'",
                vuln.getProject().getId(), vuln.getId()
        );
    }

    @Transactional
    public User assignUserToVulnerability(VulnerabilityAssignAction action) {
        // 1. Look up entities
        Vulnerability vuln = vulnerabilityRepository.findById(action.vulnId())
                .orElseThrow(() -> new EntityNotFoundException("Vulnerability not found"));

        User user = userRepository.findById(action.userId())
                .orElseThrow(() -> new EntityNotFoundException("User not found"));

        Long projectId = vuln.getProject().getId();

        // Ensure the user being assigned is a member of the project
        ProjectRole projectRole = userProjectRepository
                .findByUserIdAndProjectId(user.getId(), projectId)
                .map(UserProject::getRole)
                .orElseThrow(() -> new AccessDeniedException("User is not a member of this project"));

        RoleInVuln vulnRole = action.role();

        // Prevent Duplicates
        UserVulnerabilityId id = new UserVulnerabilityId(user.getId(), vuln.getId());
        if (userVulnerabilityRepository.existsById(id)) {
            throw new IllegalStateException("You are already assigned to this vulnerability");
        }

        // Validate the user's Project Role is allowed to take on the RoleInVuln thing
        switch (projectRole) {
            case PROGRAMMER -> {
                if (vulnRole != RoleInVuln.ASSIGNEE) {
                    throw new IllegalArgumentException("Programmers can only be assigned as ASSIGNEE");
                }
            }
            case TESTER -> {
                if (vulnRole != RoleInVuln.VERIFIER) {
                    throw new IllegalArgumentException("Testers can only be assigned as VERIFIER");
                }
            }
            case LEAD -> {
                // Leads can be assigned any role
            }
            default -> throw new AccessDeniedException("Unknown project role");
        }

        // Link user and vulnerability with verified role
        UserVulnerability link = UserVulnerability.builder()
                .id(id)
                .user(user)
                .vulnerability(vuln)
                .role(vulnRole)
                .assignedAt(Instant.now()) // optional audit info
                .build();

        //noinspection DuplicatedCode
        userVulnerabilityRepository.save(link);

        // Update vulnerability status depending on role
        switch (vulnRole) {
            case ASSIGNEE -> {
                if (vuln.getStatus() == VulnStatus.REPORTED) {
                    vuln.setStatus(VulnStatus.IN_PROGRESS);
                    vuln.setUpdatedAt(Instant.now());
                }
            }
            case VERIFIER -> {
                if (vuln.getStatus() == VulnStatus.PATCHED) {
                    vuln.setStatus(VulnStatus.UNDER_REVIEW);
                    vuln.setUpdatedAt(Instant.now());
                }
            }
        }
        vulnerabilityRepository.save(vuln);

        notificationService.notify(
                user.getId(), NotificationType.VULN_ASSIGNED,
                "You were assigned as " + vulnRole.name().toLowerCase() + " to '" + vuln.getTitle() + "' in '" + vuln.getProject().getName() + "'",
                projectId, vuln.getId()
        );
        return user;
    }

    // Revoke a user from a vulnerability role
    @Transactional
    public User revokeUserFromVulnerability(VulnerabilityRevokeAction action) {
        Vulnerability vuln = vulnerabilityRepository.findById(action.vulnId())
                .orElseThrow(() -> new EntityNotFoundException("Vulnerability not found"));

        User user = userRepository.findById(action.userId())
                .orElseThrow(() -> new EntityNotFoundException("User not found"));

        // 1. Fetch the UserVulnerability link
        UserVulnerability link = userVulnerabilityRepository.findByUserIdAndVulnerabilityId(action.userId(), action.vulnId())
                .orElseThrow(() -> new EntityNotFoundException("User is not assigned to this vulnerability"));

        // Get the users role in the vulnerability
        RoleInVuln role = link.getRole();

        // 2. Remove the link
        userVulnerabilityRepository.delete(link);

        // 3. If the role is ASSIGNEE and no more assignees remain, revert vuln status
        if (role == RoleInVuln.ASSIGNEE) {
            boolean hasOtherAssignees = userVulnerabilityRepository.existsByVulnerabilityIdAndRole(action.vulnId(), RoleInVuln.ASSIGNEE);
            if (!hasOtherAssignees && vuln.getStatus() == VulnStatus.IN_PROGRESS) {
                vuln.setStatus(VulnStatus.REPORTED);
                vuln.setReportedAt(null);
            }
        }

        // 4. If the role is VERIFIER and no more verifiers remain, revert vuln status
        if (role == RoleInVuln.VERIFIER) {
            boolean hasOtherVerifiers = userVulnerabilityRepository
                    .existsByVulnerabilityIdAndRole(action.vulnId(), RoleInVuln.VERIFIER);

            if (!hasOtherVerifiers && vuln.getStatus() == VulnStatus.UNDER_REVIEW) {
                vuln.setStatus(VulnStatus.PATCHED);
            }
        }
        vulnerabilityRepository.save(vuln);

        notificationService.notify(
                user.getId(), NotificationType.VULN_UNASSIGNED,
                "You were unassigned from '" + vuln.getTitle() + "' in '" + vuln.getProject().getName() + "'",
                vuln.getProject().getId(), vuln.getId()
        );
        return user;
    }


    private VulnerabilityWithProjectDto toDto(Vulnerability v) {
        return new VulnerabilityWithProjectDto(
                v.getId(), v.getTitle(), v.getDescription(),
                v.getCveId(), v.getCweId(), v.getSeverity(), v.getStatus(),
                v.getUpdatedAt(), v.getReportedAt(), v.getDueAt(),
                v.getPatchedAt(), v.getVerifiedAt(), v.getRepository(), v.getCommitHash(),
                v.getProject().getId(), v.getProject().getName()
        );
    }

    public List<VulnerabilityWithProjectDto> getReportedByMe(Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(userId, RoleInVuln.REPORTER);

        return links.stream()
                .map(uv -> toDto(uv.getVulnerability()))
                .collect(Collectors.toList());
    }

    public List<Vulnerability> getReportedByMeInProject(Long projectId, Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was a REPORTER (not user vs admin because we are accessing uservuln defined role)
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(userId, RoleInVuln.REPORTER);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .filter(v -> v.getProject().getId().equals(projectId))  // ✅ filter by project
                .collect(Collectors.toList());
    }

    @Transactional
    public List<VulnerabilityWithProjectDto> getAssignedToMe(Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        return userVulnerabilityRepository.findByUserIdAndRole(userId, RoleInVuln.ASSIGNEE).stream()
                .map(uv -> toDto(uv.getVulnerability()))
                .toList();
    }

    public List<Vulnerability> getAssignedToMeInProject(Long projectId, Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();


        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was an ASSIGNEE
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(userId, RoleInVuln.ASSIGNEE);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .filter(v -> v.getProject().getId().equals(projectId))  // ✅ filter by project
                .collect(Collectors.toList());
    }

    @Transactional
    public List<VulnerabilityWithProjectDto> getVerifiedByMe(Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        return userVulnerabilityRepository.findByUserIdAndRole(userId, RoleInVuln.VERIFIER).stream()
                .map(uv -> toDto(uv.getVulnerability()))
                .toList();
    }

    public List<Vulnerability> getVerifiedByMeInProject(Long projectId, Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();


        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was an ASSIGNEE
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(userId, RoleInVuln.VERIFIER);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .filter(v -> v.getProject().getId().equals(projectId))  // ✅ filter by project
                .collect(Collectors.toList());
    }

    public List<Vulnerability> getReportedByUserInProject(UserProjectRelationshipRequest request) {
        userRepository.findById(request.userId())
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was a REPORTER (not user vs admin because we are accessing uservuln defined role)
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(request.userId(), RoleInVuln.REPORTER);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .filter(v -> v.getProject().getId().equals(request.projectId()))  // ✅ filter by project
                .collect(Collectors.toList());
    }

    public List<Vulnerability> getAssignedToUserInProject(UserProjectRelationshipRequest request) {
        userRepository.findById(request.userId())
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was a ASSIGNEE (not user vs admin because we are accessing uservuln defined role)
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(request.userId(), RoleInVuln.ASSIGNEE);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .filter(v -> v.getProject().getId().equals(request.projectId()))  // ✅ filter by project
                .collect(Collectors.toList());
    }

    public List<Vulnerability> getVerifiedByUserInProject(UserProjectRelationshipRequest request) {
        userRepository.findById(request.userId())
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was a VERIFIER (not user vs admin because we are accessing uservuln defined role)
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(request.userId(), RoleInVuln.VERIFIER);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .filter(v -> v.getProject().getId().equals(request.projectId()))  // ✅ filter by project
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public List<VulnerabilityAssignmentDto> getProjectAssignments(Long projectId) {
        List<UserVulnerability> uvs = userVulnerabilityRepository.findByVulnerabilityProjectIdWithUsers(projectId);

        // Group all UserVulnerability records by vulnerability id (preserving insertion order)
        Map<Long, List<UserVulnerability>> grouped = uvs.stream()
                .collect(Collectors.groupingBy(uv -> uv.getVulnerability().getId(), LinkedHashMap::new, Collectors.toList()));

        return grouped.entrySet().stream()
                .map(entry -> {
                    Vulnerability v = entry.getValue().get(0).getVulnerability();
                    List<AssignmentEntry> assignments = entry.getValue().stream()
                            .map(uv -> new AssignmentEntry(
                                    uv.getUser().getId(),
                                    uv.getUser().getFirstname(),
                                    uv.getUser().getLastname(),
                                    uv.getRole(),
                                    uv.getAssignedAt(),
                                    uv.isSelfAssigned()
                            ))
                            .collect(Collectors.toList());
                    return new VulnerabilityAssignmentDto(
                            v.getId(), v.getTitle(), v.getDescription(),
                            v.getCveId(), v.getCweId(), v.getSeverity(), v.getStatus(),
                            v.getReportedAt(), v.getDueAt(), v.getPatchedAt(), v.getVerifiedAt(),
                            v.getRepository(), v.getCommitHash(), assignments
                    );
                })
                .collect(Collectors.toList());
    }
}

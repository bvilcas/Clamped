package com.brentcodes.springboot.librarysystem.uservulnerability;

import com.brentcodes.springboot.librarysystem.userproject.ProjectRole;
import com.brentcodes.springboot.librarysystem.userproject.ProjectSecurity;
import com.brentcodes.springboot.librarysystem.userproject.UserProject;
import com.brentcodes.springboot.librarysystem.userproject.UserProjectRepository;
import com.brentcodes.springboot.librarysystem.vulnerability.VulnStatus;
import com.brentcodes.springboot.librarysystem.vulnerability.Vulnerability;
import com.brentcodes.springboot.librarysystem.vulnerability.VulnerabilityRepository;
import com.brentcodes.springboot.librarysystem.user.User;
import com.brentcodes.springboot.librarysystem.user.UserPrincipal;
import com.brentcodes.springboot.librarysystem.user.UserRepository;
import jakarta.persistence.EntityNotFoundException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.RequestBody;

import java.time.Instant;
import java.util.List;
import java.util.stream.Collectors;

// Responsible for user and vulnerability logic (anything to do with their relationship) so that includes finding the books of a user
@Service
public class UserVulnerabilityService {

    private final UserVulnerabilityRepository userVulnerabilityRepository;
    private final UserRepository userRepository;
    private final VulnerabilityRepository vulnerabilityRepository;
    private final ProjectSecurity projectSecurity;
    private final UserProjectRepository userProjectRepository;

    @Autowired // Not required for single constructors... depends on dependency injection
    public UserVulnerabilityService(UserVulnerabilityRepository userVulnerabilityRepository, UserRepository userRepository, VulnerabilityRepository vulnerabilityRepository,  ProjectSecurity projectSecurity,  UserProjectRepository userProjectRepository) {
        this.userVulnerabilityRepository = userVulnerabilityRepository;
        this.userRepository = userRepository;
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.projectSecurity = projectSecurity;
        this.userProjectRepository = userProjectRepository;
    }

    @Transactional
    public void selfAssignToVulnerability(VulnerabilitySelfAssignRevoke selfAssign, Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));


        Vulnerability vuln = vulnerabilityRepository.getVulnerabilitiesById(selfAssign.vulnId());

        // Make sure the user is a member of the project
        userProjectRepository.findByUserIdAndProjectId(user.getId(), selfAssign.projectId())
                .map(UserProject::getRole)
                .orElseThrow(() -> new AccessDeniedException("User is not a member of this project"));


        // Prevent Duplicates
        UserVulnerabilityId id = new UserVulnerabilityId(user.getId(), vuln.getId());
        if (userVulnerabilityRepository.existsById(id)) {
            throw new IllegalStateException("You are already assigned to this vulnerability");
        }

        // Determine project role and map to RoleInVuln
        ProjectRole projectRole = projectSecurity.getProjectRole(authentication, vuln.getProject().getId());
        RoleInVuln roleInVuln = switch (projectRole) {
            case PROGRAMMER, LEAD -> RoleInVuln.ASSIGNEE; // Members and leads become assignees
            case TESTER -> RoleInVuln.VERIFIER; // Testers become verifiers
            default -> throw new AccessDeniedException("You are not allowed to self-assign to this vulnerability");
        };

        // Link user and vulnerability with verified role
        UserVulnerability link = UserVulnerability.builder()
                .id(id)
                .user(user)
                .vulnerability(vuln)
                .role(roleInVuln)
                .selfAssigned(true) // optional but good for clarity
                .assignedAt(Instant.now()) // optional audit info
                .build();

        //noinspection DuplicatedCode
        userVulnerabilityRepository.save(link);

        // Update vulnerability status depending on role
        switch (roleInVuln) {
            case ASSIGNEE -> {
                if (vuln.getStatus() == VulnStatus.REPORTED) {
                    vuln.setStatus(VulnStatus.IN_PROGRESS);
                    vuln.setUpdatedAt(Instant.now());
                }
            }
            case VERIFIER -> {
                if (vuln.getStatus() == VulnStatus.PATCHED) {
                    vuln.setStatus(VulnStatus.UNDER_REVIEW);
                    vuln.setUpdatedAt(Instant.now());
                }
            }
        }
        // Save the vuln with updated state
        vulnerabilityRepository.save(vuln);
    }

    @Transactional
    public void selfRevokeFromVulnerability(VulnerabilitySelfAssignRevoke selfRevoke, Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));
        Vulnerability vuln = vulnerabilityRepository.getVulnerabilitiesById(selfRevoke.vulnId());

        Long projectId = vuln.getProject().getId();

        // Ensure the user is a member of the project
        userProjectRepository.findByUserIdAndProjectId(user.getId(), projectId)
                .orElseThrow(() -> new AccessDeniedException("User is not a member of this project"));

        // Get the existing UserVulnerability link
        UserVulnerability link = userVulnerabilityRepository
                .findByUserIdAndVulnerabilityId(user.getId(), vuln.getId())
                .orElseThrow(() -> new IllegalStateException("You are not assigned to this vulnerability"));

        RoleInVuln roleInVuln = link.getRole();

        // Delete the link (self unassign)
        userVulnerabilityRepository.delete(link);

        // 5️⃣ Update vulnerability status depending on the role revoked
        switch (roleInVuln) {
            case ASSIGNEE -> {
                boolean hasOtherAssignees = userVulnerabilityRepository
                        .existsByVulnerabilityIdAndRole(selfRevoke.vulnId(), RoleInVuln.ASSIGNEE);
                if (!hasOtherAssignees && vuln.getStatus() == VulnStatus.IN_PROGRESS) {
                    vuln.setStatus(VulnStatus.REPORTED);
                    vuln.setUpdatedAt(Instant.now());
                }
            }
            case VERIFIER -> {
                boolean hasOtherVerifiers = userVulnerabilityRepository
                        .existsByVulnerabilityIdAndRole(selfRevoke.vulnId(), RoleInVuln.VERIFIER);
                if (!hasOtherVerifiers && vuln.getStatus() == VulnStatus.UNDER_REVIEW) {
                    vuln.setStatus(VulnStatus.PATCHED);
                    vuln.setUpdatedAt(Instant.now());
                }
            }
        }

        // Save the vuln with updated state
        vulnerabilityRepository.save(vuln);
    }

    @Transactional
    public User assignUserToVulnerability(VulnerabilityAssignAction action) {
        // 1. Look up entities
        Vulnerability vuln = vulnerabilityRepository.findById(action.vulnId())
                .orElseThrow(() -> new EntityNotFoundException("Vulnerability not found"));

        User user = userRepository.findById(action.userId())
                .orElseThrow(() -> new EntityNotFoundException("User not found"));

        Long projectId = vuln.getProject().getId();

        // Ensure the user being assigned is a member of the project
        ProjectRole projectRole = userProjectRepository
                .findByUserIdAndProjectId(user.getId(), projectId)
                .map(UserProject::getRole)
                .orElseThrow(() -> new AccessDeniedException("User is not a member of this project"));

        RoleInVuln vulnRole = action.role();

        // Prevent Duplicates
        UserVulnerabilityId id = new UserVulnerabilityId(user.getId(), vuln.getId());
        if (userVulnerabilityRepository.existsById(id)) {
            throw new IllegalStateException("You are already assigned to this vulnerability");
        }

        // Validate the user's Project Role is allowed to take on the RoleInVuln thing
        switch (projectRole) {
            case PROGRAMMER -> {
                if (vulnRole != RoleInVuln.ASSIGNEE) {
                    throw new IllegalArgumentException("Programmers can only be assigned as ASSIGNEE");
                }
            }
            case TESTER -> {
                if (vulnRole != RoleInVuln.VERIFIER) {
                    throw new IllegalArgumentException("Testers can only be assigned as VERIFIER");
                }
            }
            case LEAD -> {
                // Leads can be assigned any role
            }
            default -> throw new AccessDeniedException("Unknown project role");
        }

        // Link user and vulnerability with verified role
        UserVulnerability link = UserVulnerability.builder()
                .id(id)
                .user(user)
                .vulnerability(vuln)
                .role(vulnRole)
                .assignedAt(Instant.now()) // optional audit info
                .build();

        //noinspection DuplicatedCode
        userVulnerabilityRepository.save(link);

        // Update vulnerability status depending on role
        switch (vulnRole) {
            case ASSIGNEE -> {
                if (vuln.getStatus() == VulnStatus.REPORTED) {
                    vuln.setStatus(VulnStatus.IN_PROGRESS);
                    vuln.setUpdatedAt(Instant.now());
                }
            }
            case VERIFIER -> {
                if (vuln.getStatus() == VulnStatus.PATCHED) {
                    vuln.setStatus(VulnStatus.UNDER_REVIEW);
                    vuln.setUpdatedAt(Instant.now());
                }
            }
        }
        vulnerabilityRepository.save(vuln);
        return user;
    }

    // Revoke a user from a vulnerability role
    @Transactional
    public User revokeUserFromVulnerability(VulnerabilityRevokeAction action) {
        Vulnerability vuln = vulnerabilityRepository.findById(action.vulnId())
                .orElseThrow(() -> new EntityNotFoundException("Vulnerability not found"));

        User user = userRepository.findById(action.userId())
                .orElseThrow(() -> new EntityNotFoundException("User not found"));

        // 1. Fetch the UserVulnerability link
        UserVulnerability link = userVulnerabilityRepository.findByUserIdAndVulnerabilityId(action.userId(), action.vulnId())
                .orElseThrow(() -> new EntityNotFoundException("User is not assigned to this vulnerability"));

        // Get the users role in the vulnerability
        RoleInVuln role = link.getRole();

        // 2. Remove the link
        userVulnerabilityRepository.delete(link);

        // 3. If the role is ASSIGNEE and no more assignees remain, revert vuln status
        if (role == RoleInVuln.ASSIGNEE) {
            boolean hasOtherAssignees = userVulnerabilityRepository.existsByVulnerabilityIdAndRole(action.vulnId(), RoleInVuln.ASSIGNEE);
            if (!hasOtherAssignees && vuln.getStatus() == VulnStatus.IN_PROGRESS) {
                vuln.setStatus(VulnStatus.REPORTED);
                vuln.setReportedAt(null);
            }
        }

        // 4. If the role is VERIFIER and no more verifiers remain, revert vuln status
        if (role == RoleInVuln.VERIFIER) {
            boolean hasOtherVerifiers = userVulnerabilityRepository
                    .existsByVulnerabilityIdAndRole(action.vulnId(), RoleInVuln.VERIFIER);

            if (!hasOtherVerifiers && vuln.getStatus() == VulnStatus.UNDER_REVIEW) {
                vuln.setStatus(VulnStatus.PATCHED);
            }
        }
        vulnerabilityRepository.save(vuln);
        return user;
    }


    public List<Vulnerability> getReportedByMe(Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();


        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was a REPORTER (not user vs admin because we are accessing uservuln defined role)
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(userId, RoleInVuln.REPORTER);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .collect(Collectors.toList()); // return mutable (modifiable list) doesn't really matter in this case
    }

    public List<Vulnerability> getReportedByMeInProject(Long projectId, Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was a REPORTER (not user vs admin because we are accessing uservuln defined role)
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(userId, RoleInVuln.REPORTER);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .filter(v -> v.getProject().getId().equals(projectId))  // ✅ filter by project
                .collect(Collectors.toList());
    }

    @Transactional
    public List<Vulnerability> getAssignedToMe(Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Same stuff as above but just shortened
        return userVulnerabilityRepository.findByUserIdAndRole(userId, RoleInVuln.ASSIGNEE).stream()
                .map(UserVulnerability::getVulnerability) // unwrap the Vulnerability entity from join table (better to do it in service than the repo to maintain consistency)
                .toList();
    }

    public List<Vulnerability> getAssignedToMeInProject(Long projectId, Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();


        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was an ASSIGNEE
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(userId, RoleInVuln.ASSIGNEE);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .filter(v -> v.getProject().getId().equals(projectId))  // ✅ filter by project
                .collect(Collectors.toList());
    }

    @Transactional
    public List<Vulnerability> getVerifiedByMe(Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();

        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Same stuff as above but just shortened
        return userVulnerabilityRepository.findByUserIdAndRole(userId, RoleInVuln.VERIFIER).stream()
                .map(UserVulnerability::getVulnerability)
                .toList();
    }

    public List<Vulnerability> getVerifiedByMeInProject(Long projectId, Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Long userId = userPrincipal.getId();


        userRepository.findById(userId)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was an ASSIGNEE
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(userId, RoleInVuln.VERIFIER);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .filter(v -> v.getProject().getId().equals(projectId))  // ✅ filter by project
                .collect(Collectors.toList());
    }

    public List<Vulnerability> getReportedByUserInProject(UserProjectRelationshipRequest request) {
        userRepository.findById(request.userId())
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was a REPORTER (not user vs admin because we are accessing uservuln defined role)
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(request.userId(), RoleInVuln.REPORTER);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .filter(v -> v.getProject().getId().equals(request.projectId()))  // ✅ filter by project
                .collect(Collectors.toList());
    }

    public List<Vulnerability> getAssignedToUserInProject(UserProjectRelationshipRequest request) {
        userRepository.findById(request.userId())
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was a ASSIGNEE (not user vs admin because we are accessing uservuln defined role)
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(request.userId(), RoleInVuln.ASSIGNEE);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .filter(v -> v.getProject().getId().equals(request.projectId()))  // ✅ filter by project
                .collect(Collectors.toList());
    }

    public List<Vulnerability> getVerifiedByUserInProject(UserProjectRelationshipRequest request) {
        userRepository.findById(request.userId())
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Fetch UserVulnerability links where the user was a VERIFIER (not user vs admin because we are accessing uservuln defined role)
        List<UserVulnerability> links = userVulnerabilityRepository.findByUserIdAndRole(request.userId(), RoleInVuln.VERIFIER);

        // Map to Vulnerability entities
        return links.stream()
                .map(UserVulnerability::getVulnerability)
                .filter(v -> v.getProject().getId().equals(request.projectId()))  // ✅ filter by project
                .collect(Collectors.toList());
    }
}
